<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Guide R pour Motus</title>
  <meta name="description" content="Guide R pour Motus">
  <meta name="generator" content="bookdown 0.6 and GitBook 2.6.7">

  <meta property="og:title" content="Guide R pour Motus" />
  <meta property="og:type" content="book" />
  
  <meta property="og:image" content="BSC_Motus_Logo.png" />
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Guide R pour Motus" />
  
  
  <meta name="twitter:image" content="BSC_Motus_Logo.png" />

<meta name="author" content="Tara L. Crewe, Zoe Crysler, et Philip Taylor">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="deployments.html">
<link rel="next" href="exploreData.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">A Minimal Book Example</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Utilisation du langage R appliqué aux données du réseau de radiotélémétrie automatisée Motus</a></li>
<li class="chapter" data-level="1" data-path="introduction.html"><a href="introduction.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul>
<li class="chapter" data-level="1.1" data-path="introduction.html"><a href="introduction.html#whatBookCovers"><i class="fa fa-check"></i><b>1.1</b> Ce que le présent guide ne montre pas</a></li>
<li class="chapter" data-level="1.2" data-path="introduction.html"><a href="introduction.html#prerequisites"><i class="fa fa-check"></i><b>1.2</b> Connaissances préalables</a></li>
<li class="chapter" data-level="1.3" data-path="introduction.html"><a href="introduction.html#sampleData"><i class="fa fa-check"></i><b>1.3</b> Ensemble de données utilisées comme exemples</a></li>
<li class="chapter" data-level="1.4" data-path="introduction.html"><a href="introduction.html#acknowledgements"><i class="fa fa-check"></i><b>1.4</b> Remerciements</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="loadingPackages.html"><a href="loadingPackages.html"><i class="fa fa-check"></i><b>2</b> Chargement des logiciels R</a><ul>
<li class="chapter" data-level="2.1" data-path="loadingPackages.html"><a href="loadingPackages.html#internalProcessing"><i class="fa fa-check"></i><b>2.1</b> Traitement interne des données</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="accessingData.html"><a href="accessingData.html"><i class="fa fa-check"></i><b>3</b> Accès aux données de détection</a><ul>
<li class="chapter" data-level="3.1" data-path="accessingData.html"><a href="accessingData.html#databaseTypes"><i class="fa fa-check"></i><b>3.1</b> Types de bases de données</a></li>
<li class="chapter" data-level="3.2" data-path="accessingData.html"><a href="accessingData.html#loadPackages"><i class="fa fa-check"></i><b>3.2</b> Chargement des logiciels R pertinents</a></li>
<li class="chapter" data-level="3.3" data-path="accessingData.html"><a href="accessingData.html#reglage-de-lenvironnement-systeme"><i class="fa fa-check"></i><b>3.3</b> Réglage de l’environnement système</a></li>
<li class="chapter" data-level="3.4" data-path="accessingData.html"><a href="accessingData.html#importDetections"><i class="fa fa-check"></i><b>3.4</b> Importation de données de détection</a><ul>
<li class="chapter" data-level="3.4.1" data-path="accessingData.html"><a href="accessingData.html#telechargement-des-donnees-dun-projet-ou-dun-recepteur-pour-la-premiere-fois"><i class="fa fa-check"></i><b>3.4.1</b> Téléchargement des données d’un projet ou d’un récepteur pour la <em>première fois</em></a></li>
<li class="chapter" data-level="3.4.2" data-path="accessingData.html"><a href="accessingData.html#userAuthentication"><i class="fa fa-check"></i><b>3.4.2</b> Authentification de l’utilisateur</a></li>
<li class="chapter" data-level="3.4.3" data-path="accessingData.html"><a href="accessingData.html#logout"><i class="fa fa-check"></i><b>3.4.3</b> Fermeture de session</a></li>
<li class="chapter" data-level="3.4.4" data-path="accessingData.html"><a href="accessingData.html#downloadData"><i class="fa fa-check"></i><b>3.4.4</b> Téléchargement de données de détection</a></li>
<li class="chapter" data-level="3.4.5" data-path="accessingData.html"><a href="accessingData.html#tagmeUpdate"><i class="fa fa-check"></i><b>3.4.5</b> Ouverture et mise à jour d’une base de données de détection locale</a></li>
<li class="chapter" data-level="3.4.6" data-path="accessingData.html"><a href="accessingData.html#tellme"><i class="fa fa-check"></i><b>3.4.6</b> Vérification de l’existence de nouvelles données</a></li>
<li class="chapter" data-level="3.4.7" data-path="accessingData.html"><a href="accessingData.html#forceMeta"><i class="fa fa-check"></i><b>3.4.7</b> Imposition d’une mise à jour/réimportation de métadonnées sur des émetteurs et des récepteurs</a></li>
<li class="chapter" data-level="3.4.8" data-path="accessingData.html"><a href="accessingData.html#metadata"><i class="fa fa-check"></i><b>3.4.8</b> Importation de l’ensemble des métadonnées sur les émetteurs et les récepteurs</a></li>
</ul></li>
<li class="chapter" data-level="3.5" data-path="accessingData.html"><a href="accessingData.html#databaseStructure"><i class="fa fa-check"></i><b>3.5</b> Structure des données</a></li>
<li class="chapter" data-level="3.6" data-path="accessingData.html"><a href="accessingData.html#verification-de-la-version-de-la-base-de-donnees-checkversion"><i class="fa fa-check"></i><b>3.6</b> Vérification de la version de la base de données {checkVersion}</a></li>
<li class="chapter" data-level="3.7" data-path="accessingData.html"><a href="accessingData.html#convertToFlat"><i class="fa fa-check"></i><b>3.7</b> Conversion d’une table SQLITE en une trame de données plate</a></li>
<li class="chapter" data-level="3.8" data-path="accessingData.html"><a href="accessingData.html#exportDetections"><i class="fa fa-check"></i><b>3.8</b> Exportation d’une trame de données «plate» sous la forme d’un fichier CSV ou RDS</a></li>
<li class="chapter" data-level="3.9" data-path="accessingData.html"><a href="accessingData.html#convention-de-noms-dobjets-r"><i class="fa fa-check"></i><b>3.9</b> Convention de noms d’objets R</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="deployments.html"><a href="deployments.html"><i class="fa fa-check"></i><b>4</b> Déploiements d’émetteurs et de récepteurs</a><ul>
<li class="chapter" data-level="4.1" data-path="deployments.html"><a href="deployments.html#chargement-des-logiciels-r-pertinents-et-reglage-de-lenvironnement-de-travail"><i class="fa fa-check"></i><b>4.1</b> Chargement des logiciels R pertinents et réglage de l’environnement de travail</a></li>
<li class="chapter" data-level="4.2" data-path="deployments.html"><a href="deployments.html#chargement-du-fichier-.motus"><i class="fa fa-check"></i><b>4.2</b> Chargement du fichier .motus</a></li>
<li class="chapter" data-level="4.3" data-path="deployments.html"><a href="deployments.html#tagDeployments"><i class="fa fa-check"></i><b>4.3</b> Déploiements d’émetteurs</a><ul>
<li class="chapter" data-level="4.3.1" data-path="deployments.html"><a href="deployments.html#telechargement-des-metadonnees-completes-sur-les-emetteurs-pour-votre-projet"><i class="fa fa-check"></i><b>4.3.1</b> Téléchargement des métadonnées complètes sur les émetteurs pour votre projet</a></li>
<li class="chapter" data-level="4.3.2" data-path="deployments.html"><a href="deployments.html#determination-du-nombre-demetteurs-enregistres"><i class="fa fa-check"></i><b>4.3.2</b> Détermination du nombre d’émetteurs enregistrés</a></li>
<li class="chapter" data-level="4.3.3" data-path="deployments.html"><a href="deployments.html#determination-du-nombre-demetteurs-enregistres-qui-ont-ete-deployes"><i class="fa fa-check"></i><b>4.3.3</b> Détermination du nombre d’émetteurs enregistrés qui ont été déployés</a></li>
<li class="chapter" data-level="4.3.4" data-path="deployments.html"><a href="deployments.html#checkNumberTagDeployments"><i class="fa fa-check"></i><b>4.3.4</b> Détermination du nombre de déploiements par émetteur</a></li>
<li class="chapter" data-level="4.3.5" data-path="deployments.html"><a href="deployments.html#localisation-des-emetteurs-deployes"><i class="fa fa-check"></i><b>4.3.5</b> Localisation des émetteurs déployés</a></li>
<li class="chapter" data-level="4.3.6" data-path="deployments.html"><a href="deployments.html#verification-de-la-completude-et-de-lexactitude-des-metadonnees-sur-les-deploiements-demetteurs"><i class="fa fa-check"></i><b>4.3.6</b> Vérification de la complétude et de l’exactitude des métadonnées sur les déploiements d’émetteurs</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="deployments.html"><a href="deployments.html#recvMetadata"><i class="fa fa-check"></i><b>4.4</b> Vérification des métadonnées sur les récepteurs</a><ul>
<li class="chapter" data-level="4.4.1" data-path="deployments.html"><a href="deployments.html#telechargement-des-metadonnees-sur-tous-les-recepteurs-dans-le-reseau"><i class="fa fa-check"></i><b>4.4.1</b> Téléchargement des métadonnées sur tous les récepteurs dans le réseau</a></li>
<li class="chapter" data-level="4.4.2" data-path="deployments.html"><a href="deployments.html#determination-du-nombre-de-recepteurs-deployes-dans-le-cadre-de-votre-projet"><i class="fa fa-check"></i><b>4.4.2</b> Détermination du nombre de récepteurs déployés dans le cadre de votre projet</a></li>
<li class="chapter" data-level="4.4.3" data-path="deployments.html"><a href="deployments.html#determination-du-moment-du-deploiement-des-recepteurs-dans-le-cadre-de-votre-projet"><i class="fa fa-check"></i><b>4.4.3</b> Détermination du moment du déploiement des récepteurs dans le cadre de votre projet</a></li>
<li class="chapter" data-level="4.4.4" data-path="deployments.html"><a href="deployments.html#localisation-des-recepteurs-deployes"><i class="fa fa-check"></i><b>4.4.4</b> Localisation des récepteurs déployés</a></li>
<li class="chapter" data-level="4.4.5" data-path="deployments.html"><a href="deployments.html#verification-de-la-completude-et-de-lexactitude-des-metadonnees-sur-les-deploiements-des-recepteurs"><i class="fa fa-check"></i><b>4.4.5</b> Vérification de la complétude et de l’exactitude des métadonnées sur les déploiements des récepteurs</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="dataCleaning.html"><a href="dataCleaning.html"><i class="fa fa-check"></i><b>5</b> Nettoyage des données</a><ul>
<li class="chapter" data-level="5.1" data-path="dataCleaning.html"><a href="dataCleaning.html#chargement-des-logiciels-requis"><i class="fa fa-check"></i><b>5.1</b> Chargement des logiciels requis</a></li>
<li class="chapter" data-level="5.2" data-path="dataCleaning.html"><a href="dataCleaning.html#chargement-des-donnees-de-detection"><i class="fa fa-check"></i><b>5.2</b> Chargement des données de détection</a></li>
<li class="chapter" data-level="5.3" data-path="dataCleaning.html"><a href="dataCleaning.html#verifications-preliminaires-des-donnees"><i class="fa fa-check"></i><b>5.3</b> Vérifications préliminaires des données</a><ul>
<li class="chapter" data-level="5.3.1" data-path="dataCleaning.html"><a href="dataCleaning.html#sommaires-de-donnees-de-detection-demetteurs"><i class="fa fa-check"></i><b>5.3.1</b> Sommaires de données de détection d’émetteurs</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="dataCleaning.html"><a href="dataCleaning.html#ambigs"><i class="fa fa-check"></i><b>5.4</b> Recherche et examen de détections ambiguës</a></li>
<li class="chapter" data-level="5.5" data-path="dataCleaning.html"><a href="dataCleaning.html#verification-de-la-validite-des-sequences-dau-moins-2-detections"><i class="fa fa-check"></i><b>5.5</b> Vérification de la validité des séquences d’au moins 2 détections</a></li>
<li class="chapter" data-level="5.6" data-path="dataCleaning.html"><a href="dataCleaning.html#filtrage-des-donnees"><i class="fa fa-check"></i><b>5.6</b> Filtrage des données</a><ul>
<li class="chapter" data-level="5.6.1" data-path="dataCleaning.html"><a href="dataCleaning.html#filtrer-et-enregistrer-le-resultat-dans-le-format-rds"><i class="fa fa-check"></i><b>5.6.1</b> Filtrer et enregistrer le résultat dans le format RDS</a></li>
<li class="chapter" data-level="5.6.2" data-path="dataCleaning.html"><a href="dataCleaning.html#enregistrer-un-filtre-personnalise-dans-la-base-de-donnees-motus-et-lappliquer-aux-donnees"><i class="fa fa-check"></i><b>5.6.2</b> Enregistrer un filtre personnalisé dans la base de données motus et l’appliquer aux données</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="exploreData.html"><a href="exploreData.html"><i class="fa fa-check"></i><b>6</b> Exploration des données avec le logiciel R de Motus</a><ul>
<li class="chapter" data-level="6.1" data-path="exploreData.html"><a href="exploreData.html#chargement-des-logiciels-requis-1"><i class="fa fa-check"></i><b>6.1</b> Chargement des logiciels requis</a></li>
<li class="chapter" data-level="6.2" data-path="exploreData.html"><a href="exploreData.html#chargement-des-donnees"><i class="fa fa-check"></i><b>6.2</b> Chargement des données</a></li>
<li class="chapter" data-level="6.3" data-path="exploreData.html"><a href="exploreData.html#dataSummaries"><i class="fa fa-check"></i><b>6.3</b> Sommaires de données</a></li>
<li class="chapter" data-level="6.4" data-path="exploreData.html"><a href="exploreData.html#dataPlotting"><i class="fa fa-check"></i><b>6.4</b> Graphiques de données</a></li>
<li class="chapter" data-level="6.5" data-path="exploreData.html"><a href="exploreData.html#mappingData"><i class="fa fa-check"></i><b>6.5</b> Cartes de données</a><ul>
<li class="chapter" data-level="6.5.1" data-path="exploreData.html"><a href="exploreData.html#googleMaps"><i class="fa fa-check"></i><b>6.5.1</b> Utilisation de Google Maps</a></li>
<li class="chapter" data-level="6.5.2" data-path="exploreData.html"><a href="exploreData.html#outlineMaps"><i class="fa fa-check"></i><b>6.5.2</b> Création de cartes muettes simples</a></li>
</ul></li>
</ul></li>
<li class="appendix"><span><b>Appendix</b></span></li>
<li class="chapter" data-level="A" data-path="appendixA.html"><a href="appendixA.html"><i class="fa fa-check"></i><b>A</b> Appendix - alltags structure</a></li>
<li class="chapter" data-level="B" data-path="annexe-b-depannage-annexe-b.html"><a href="annexe-b-depannage-annexe-b.html"><i class="fa fa-check"></i><b>B</b> Annexe B - Dépannage {#Annexe B}</a><ul>
<li class="chapter" data-level="B.1" data-path="annexe-b-depannage-annexe-b.html"><a href="annexe-b-depannage-annexe-b.html#motusLogout"><i class="fa fa-check"></i><b>B.1</b> Fermeture du logiciel motus</a></li>
<li class="chapter" data-level="B.2" data-path="annexe-b-depannage-annexe-b.html"><a href="annexe-b-depannage-annexe-b.html#resumeDownload"><i class="fa fa-check"></i><b>B.2</b> Reprise du téléchargement de données</a></li>
<li class="chapter" data-level="B.3" data-path="annexe-b-depannage-annexe-b.html"><a href="annexe-b-depannage-annexe-b.html#messages-derreur-courants-et-solutions"><i class="fa fa-check"></i><b>B.3</b> Messages d’erreur courants et solutions</a><ul>
<li class="chapter" data-level="B.3.1" data-path="annexe-b-depannage-annexe-b.html"><a href="annexe-b-depannage-annexe-b.html#je-recois-le-message-auto-disconnecting-sqliteconnection-une-ou-plusieurs-fois-apres-avoir-utilise-la-fonction-tagme."><i class="fa fa-check"></i><b>B.3.1</b> Je reçois le message «Auto-disconnecting SQLiteConnection» une ou plusieurs fois après avoir utilisé la fonction tagme().</a></li>
<li class="chapter" data-level="B.3.2" data-path="annexe-b-depannage-annexe-b.html"><a href="annexe-b-depannage-annexe-b.html#je-recois-le-message-internal-server-error-pendant-que-jutilise-la-fonction-tagme-update-true."><i class="fa fa-check"></i><b>B.3.2</b> Je reçois le message «Internal Server Error» pendant que j’utilise la fonction tagme (…, update = TRUE).</a></li>
<li class="chapter" data-level="B.3.3" data-path="annexe-b-depannage-annexe-b.html"><a href="annexe-b-depannage-annexe-b.html#je-recois-le-message-error-forbidden-pendant-que-jutilise-la-fonction-tagme."><i class="fa fa-check"></i><b>B.3.3</b> Je reçois le message «Error: Forbidden» pendant que j’utilise la fonction tagme().</a></li>
<li class="chapter" data-level="B.3.4" data-path="annexe-b-depannage-annexe-b.html"><a href="annexe-b-depannage-annexe-b.html#je-recois-le-message-error-object-xxxx-not-found-relatif-au-nom-dune-table-ou-dun-champ-ou-encore-certains-de-vos-exemples-dans-le-guide-ne-fonctionnent-pas."><i class="fa fa-check"></i><b>B.3.4</b> Je reçois le message «Error: Object ‘xxxx’ not found», relatif au nom d’une table ou d’un champ, ou encore certains de vos exemples dans le guide ne fonctionnent pas.</a></li>
<li class="chapter" data-level="B.3.5" data-path="annexe-b-depannage-annexe-b.html"><a href="annexe-b-depannage-annexe-b.html#je-recois-le-message-error-in-rsqlite_connectdbname-loadable.extensions-flags-vfs-could-not-connect-to-database-unable-to-open-database-file-lorsque-je-tente-dexecuter-la-fonction-tagme."><i class="fa fa-check"></i><b>B.3.5</b> Je reçois le message «Error in rsqlite_connect(dbname, loadable.extensions, flags, vfs): Could not connect to database: unable to open database file» lorsque je tente d’exécuter la fonction tagme().</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="C" data-path="appendixC.html"><a href="appendixC.html"><i class="fa fa-check"></i><b>C</b> Annexe C - Le logiciel R de Motus</a><ul>
<li class="chapter" data-level="C.1" data-path="appendixC.html"><a href="appendixC.html#checkVersion.B"><i class="fa fa-check"></i><b>C.1</b> checkVersion</a><ul>
<li class="chapter" data-level="C.1.1" data-path="appendixC.html"><a href="appendixC.html#description"><i class="fa fa-check"></i><b>C.1.1</b> Description</a></li>
<li class="chapter" data-level="C.1.2" data-path="appendixC.html"><a href="appendixC.html#dependances"><i class="fa fa-check"></i><b>C.1.2</b> Dépendances</a></li>
<li class="chapter" data-level="C.1.3" data-path="appendixC.html"><a href="appendixC.html#exemple"><i class="fa fa-check"></i><b>C.1.3</b> Exemple</a></li>
</ul></li>
<li class="chapter" data-level="C.2" data-path="appendixC.html"><a href="appendixC.html#sunRiseSet"><i class="fa fa-check"></i><b>C.2</b> sunRiseSet</a><ul>
<li class="chapter" data-level="C.2.1" data-path="appendixC.html"><a href="appendixC.html#description-1"><i class="fa fa-check"></i><b>C.2.1</b> Description</a></li>
<li class="chapter" data-level="C.2.2" data-path="appendixC.html"><a href="appendixC.html#dependances-1"><i class="fa fa-check"></i><b>C.2.2</b> Dépendances</a></li>
<li class="chapter" data-level="C.2.3" data-path="appendixC.html"><a href="appendixC.html#exemple-1"><i class="fa fa-check"></i><b>C.2.3</b> Exemple</a></li>
</ul></li>
<li class="chapter" data-level="C.3" data-path="appendixC.html"><a href="appendixC.html#plotAllTagsCoor"><i class="fa fa-check"></i><b>C.3</b> plotAllTagsCoord</a><ul>
<li class="chapter" data-level="C.3.1" data-path="appendixC.html"><a href="appendixC.html#description-2"><i class="fa fa-check"></i><b>C.3.1</b> Description</a></li>
<li class="chapter" data-level="C.3.2" data-path="appendixC.html"><a href="appendixC.html#dependances-2"><i class="fa fa-check"></i><b>C.3.2</b> Dépendances</a></li>
<li class="chapter" data-level="C.3.3" data-path="appendixC.html"><a href="appendixC.html#exemple-2"><i class="fa fa-check"></i><b>C.3.3</b> Exemple</a></li>
</ul></li>
<li class="chapter" data-level="C.4" data-path="appendixC.html"><a href="appendixC.html#plotAllTagsSite"><i class="fa fa-check"></i><b>C.4</b> plotAllTagsSite</a><ul>
<li class="chapter" data-level="C.4.1" data-path="appendixC.html"><a href="appendixC.html#description-3"><i class="fa fa-check"></i><b>C.4.1</b> Description</a></li>
<li class="chapter" data-level="C.4.2" data-path="appendixC.html"><a href="appendixC.html#dependances-3"><i class="fa fa-check"></i><b>C.4.2</b> Dépendances</a></li>
<li class="chapter" data-level="C.4.3" data-path="appendixC.html"><a href="appendixC.html#exemple-3"><i class="fa fa-check"></i><b>C.4.3</b> Exemple</a></li>
</ul></li>
<li class="chapter" data-level="C.5" data-path="appendixC.html"><a href="appendixC.html#plotDailySiteSum"><i class="fa fa-check"></i><b>C.5</b> plotDailySiteSum</a><ul>
<li class="chapter" data-level="C.5.1" data-path="appendixC.html"><a href="appendixC.html#description-4"><i class="fa fa-check"></i><b>C.5.1</b> Description</a></li>
<li class="chapter" data-level="C.5.2" data-path="appendixC.html"><a href="appendixC.html#dependances-4"><i class="fa fa-check"></i><b>C.5.2</b> Dépendances</a></li>
<li class="chapter" data-level="C.5.3" data-path="appendixC.html"><a href="appendixC.html#exemple-4"><i class="fa fa-check"></i><b>C.5.3</b> Exemple</a></li>
</ul></li>
<li class="chapter" data-level="C.6" data-path="appendixC.html"><a href="appendixC.html#plotRouteMap"><i class="fa fa-check"></i><b>C.6</b> plotRouteMap</a><ul>
<li class="chapter" data-level="C.6.1" data-path="appendixC.html"><a href="appendixC.html#description-5"><i class="fa fa-check"></i><b>C.6.1</b> Description</a></li>
<li class="chapter" data-level="C.6.2" data-path="appendixC.html"><a href="appendixC.html#exemple-5"><i class="fa fa-check"></i><b>C.6.2</b> Exemple</a></li>
</ul></li>
<li class="chapter" data-level="C.7" data-path="appendixC.html"><a href="appendixC.html#plotSite"><i class="fa fa-check"></i><b>C.7</b> plotSite</a><ul>
<li class="chapter" data-level="C.7.1" data-path="appendixC.html"><a href="appendixC.html#description-6"><i class="fa fa-check"></i><b>C.7.1</b> Description</a></li>
<li class="chapter" data-level="C.7.2" data-path="appendixC.html"><a href="appendixC.html#dependances-5"><i class="fa fa-check"></i><b>C.7.2</b> Dépendances</a></li>
<li class="chapter" data-level="C.7.3" data-path="appendixC.html"><a href="appendixC.html#exemple-6"><i class="fa fa-check"></i><b>C.7.3</b> Exemple</a></li>
</ul></li>
<li class="chapter" data-level="C.8" data-path="appendixC.html"><a href="appendixC.html#plotSiteSig"><i class="fa fa-check"></i><b>C.8</b> plotSiteSig</a><ul>
<li class="chapter" data-level="C.8.1" data-path="appendixC.html"><a href="appendixC.html#description-7"><i class="fa fa-check"></i><b>C.8.1</b> Description</a></li>
<li class="chapter" data-level="C.8.2" data-path="appendixC.html"><a href="appendixC.html#dependances-6"><i class="fa fa-check"></i><b>C.8.2</b> Dépendances</a></li>
<li class="chapter" data-level="C.8.3" data-path="appendixC.html"><a href="appendixC.html#exemple-7"><i class="fa fa-check"></i><b>C.8.3</b> Exemple</a></li>
</ul></li>
<li class="chapter" data-level="C.9" data-path="appendixC.html"><a href="appendixC.html#plotTagSig"><i class="fa fa-check"></i><b>C.9</b> plotTagSig</a><ul>
<li class="chapter" data-level="C.9.1" data-path="appendixC.html"><a href="appendixC.html#description-8"><i class="fa fa-check"></i><b>C.9.1</b> Description</a></li>
<li class="chapter" data-level="C.9.2" data-path="appendixC.html"><a href="appendixC.html#dependances-7"><i class="fa fa-check"></i><b>C.9.2</b> Dépendances</a></li>
<li class="chapter" data-level="C.9.3" data-path="appendixC.html"><a href="appendixC.html#exemple-8"><i class="fa fa-check"></i><b>C.9.3</b> Exemple</a></li>
</ul></li>
<li class="chapter" data-level="C.10" data-path="appendixC.html"><a href="appendixC.html#simSiteDet"><i class="fa fa-check"></i><b>C.10</b> simSiteDet</a><ul>
<li class="chapter" data-level="C.10.1" data-path="appendixC.html"><a href="appendixC.html#description-9"><i class="fa fa-check"></i><b>C.10.1</b> Description</a></li>
<li class="chapter" data-level="C.10.2" data-path="appendixC.html"><a href="appendixC.html#dependances-8"><i class="fa fa-check"></i><b>C.10.2</b> Dépendances</a></li>
<li class="chapter" data-level="C.10.3" data-path="appendixC.html"><a href="appendixC.html#exemple-9"><i class="fa fa-check"></i><b>C.10.3</b> Exemple</a></li>
</ul></li>
<li class="chapter" data-level="C.11" data-path="appendixC.html"><a href="appendixC.html#siteSum"><i class="fa fa-check"></i><b>C.11</b> siteSum</a><ul>
<li class="chapter" data-level="C.11.1" data-path="appendixC.html"><a href="appendixC.html#description-10"><i class="fa fa-check"></i><b>C.11.1</b> Description</a></li>
<li class="chapter" data-level="C.11.2" data-path="appendixC.html"><a href="appendixC.html#dependances-9"><i class="fa fa-check"></i><b>C.11.2</b> Dépendances</a></li>
<li class="chapter" data-level="C.11.3" data-path="appendixC.html"><a href="appendixC.html#exemple-10"><i class="fa fa-check"></i><b>C.11.3</b> Exemple</a></li>
</ul></li>
<li class="chapter" data-level="C.12" data-path="appendixC.html"><a href="appendixC.html#siteSumDaily"><i class="fa fa-check"></i><b>C.12</b> siteSumDaily</a><ul>
<li class="chapter" data-level="C.12.1" data-path="appendixC.html"><a href="appendixC.html#description-11"><i class="fa fa-check"></i><b>C.12.1</b> Description</a></li>
<li class="chapter" data-level="C.12.2" data-path="appendixC.html"><a href="appendixC.html#dependances-10"><i class="fa fa-check"></i><b>C.12.2</b> Dépendances</a></li>
<li class="chapter" data-level="C.12.3" data-path="appendixC.html"><a href="appendixC.html#exemple-11"><i class="fa fa-check"></i><b>C.12.3</b> Exemple</a></li>
</ul></li>
<li class="chapter" data-level="C.13" data-path="appendixC.html"><a href="appendixC.html#siteTrans"><i class="fa fa-check"></i><b>C.13</b> siteTrans</a><ul>
<li class="chapter" data-level="C.13.1" data-path="appendixC.html"><a href="appendixC.html#description-12"><i class="fa fa-check"></i><b>C.13.1</b> Description</a></li>
<li class="chapter" data-level="C.13.2" data-path="appendixC.html"><a href="appendixC.html#dependances-11"><i class="fa fa-check"></i><b>C.13.2</b> Dépendances</a></li>
<li class="chapter" data-level="C.13.3" data-path="appendixC.html"><a href="appendixC.html#exemple-12"><i class="fa fa-check"></i><b>C.13.3</b> Exemple</a></li>
</ul></li>
<li class="chapter" data-level="C.14" data-path="appendixC.html"><a href="appendixC.html#tagSum"><i class="fa fa-check"></i><b>C.14</b> tagSum</a><ul>
<li class="chapter" data-level="C.14.1" data-path="appendixC.html"><a href="appendixC.html#description-13"><i class="fa fa-check"></i><b>C.14.1</b> Description</a></li>
<li class="chapter" data-level="C.14.2" data-path="appendixC.html"><a href="appendixC.html#dependances-12"><i class="fa fa-check"></i><b>C.14.2</b> Dépendances</a></li>
<li class="chapter" data-level="C.14.3" data-path="appendixC.html"><a href="appendixC.html#exemple-13"><i class="fa fa-check"></i><b>C.14.3</b> Exemple</a></li>
</ul></li>
<li class="chapter" data-level="C.15" data-path="appendixC.html"><a href="appendixC.html#tagSumSite"><i class="fa fa-check"></i><b>C.15</b> tagSumSite</a><ul>
<li class="chapter" data-level="C.15.1" data-path="appendixC.html"><a href="appendixC.html#description-14"><i class="fa fa-check"></i><b>C.15.1</b> Description</a></li>
<li class="chapter" data-level="C.15.2" data-path="appendixC.html"><a href="appendixC.html#dependances-13"><i class="fa fa-check"></i><b>C.15.2</b> Dépendances</a></li>
<li class="chapter" data-level="C.15.3" data-path="appendixC.html"><a href="appendixC.html#exemple-14"><i class="fa fa-check"></i><b>C.15.3</b> Exemple</a></li>
</ul></li>
<li class="chapter" data-level="C.16" data-path="appendixC.html"><a href="appendixC.html#timeToSunriset"><i class="fa fa-check"></i><b>C.16</b> timeToSunriset</a><ul>
<li class="chapter" data-level="C.16.1" data-path="appendixC.html"><a href="appendixC.html#description-15"><i class="fa fa-check"></i><b>C.16.1</b> Description</a></li>
<li class="chapter" data-level="C.16.2" data-path="appendixC.html"><a href="appendixC.html#dependances-14"><i class="fa fa-check"></i><b>C.16.2</b> Dépendances</a></li>
<li class="chapter" data-level="C.16.3" data-path="appendixC.html"><a href="appendixC.html#exemple-15"><i class="fa fa-check"></i><b>C.16.3</b> Exemple</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="D" data-path="appendixD.html"><a href="appendixD.html"><i class="fa fa-check"></i><b>D</b> Annexe D - Le logiciel motusClient - Fonctions de filtrage de données</a><ul>
<li class="chapter" data-level="D.1" data-path="appendixD.html"><a href="appendixD.html#listRunsFilters"><i class="fa fa-check"></i><b>D.1</b> listRunsFilters</a><ul>
<li class="chapter" data-level="D.1.1" data-path="appendixD.html"><a href="appendixD.html#description-16"><i class="fa fa-check"></i><b>D.1.1</b> Description</a></li>
</ul></li>
<li class="chapter" data-level="D.2" data-path="appendixD.html"><a href="appendixD.html#dependances-15"><i class="fa fa-check"></i><b>D.2</b> Dépendances</a></li>
<li class="chapter" data-level="D.3" data-path="appendixD.html"><a href="appendixD.html#exemple-16"><i class="fa fa-check"></i><b>D.3</b> Exemple</a></li>
<li class="chapter" data-level="D.4" data-path="appendixD.html"><a href="appendixD.html#createRunsFilter"><i class="fa fa-check"></i><b>D.4</b> createRunsFilter</a><ul>
<li class="chapter" data-level="D.4.1" data-path="appendixD.html"><a href="appendixD.html#description-17"><i class="fa fa-check"></i><b>D.4.1</b> Description</a></li>
<li class="chapter" data-level="D.4.2" data-path="appendixD.html"><a href="appendixD.html#dependances-16"><i class="fa fa-check"></i><b>D.4.2</b> Dépendances</a></li>
<li class="chapter" data-level="D.4.3" data-path="appendixD.html"><a href="appendixD.html#exemple-17"><i class="fa fa-check"></i><b>D.4.3</b> Exemple</a></li>
</ul></li>
<li class="chapter" data-level="D.5" data-path="appendixD.html"><a href="appendixD.html#getRunsFilters"><i class="fa fa-check"></i><b>D.5</b> getRunsFilters</a><ul>
<li class="chapter" data-level="D.5.1" data-path="appendixD.html"><a href="appendixD.html#description-18"><i class="fa fa-check"></i><b>D.5.1</b> Description</a></li>
<li class="chapter" data-level="D.5.2" data-path="appendixD.html"><a href="appendixD.html#dependances-17"><i class="fa fa-check"></i><b>D.5.2</b> Dépendances</a></li>
<li class="chapter" data-level="D.5.3" data-path="appendixD.html"><a href="appendixD.html#exemple-18"><i class="fa fa-check"></i><b>D.5.3</b> Exemple</a></li>
</ul></li>
<li class="chapter" data-level="D.6" data-path="appendixD.html"><a href="appendixD.html#writeRunsFilter"><i class="fa fa-check"></i><b>D.6</b> writeRunsFilter</a><ul>
<li class="chapter" data-level="D.6.1" data-path="appendixD.html"><a href="appendixD.html#description-19"><i class="fa fa-check"></i><b>D.6.1</b> Description</a></li>
<li class="chapter" data-level="D.6.2" data-path="appendixD.html"><a href="appendixD.html#dependances-18"><i class="fa fa-check"></i><b>D.6.2</b> Dépendances</a></li>
<li class="chapter" data-level="D.6.3" data-path="appendixD.html"><a href="appendixD.html#exemples"><i class="fa fa-check"></i><b>D.6.3</b> Exemples</a></li>
</ul></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Guide R pour Motus</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="dataCleaning" class="section level1">
<h1><span class="header-section-number">Chapter 5</span> Nettoyage des données</h1>
<p>Il peut arriver que des données de détection d’émetteurs dans votre base soient incorrectes; les «erreurs» peuvent avoir trois causes.</p>
<p>Premièrement, les récepteurs peuvent détecter du bruit radioélectrique aléatoire (des parasites) qu’ils interprètent comme étant de véritables signaux provenant d’émetteurs. Le phénomène produit ce qu’on appelle des faux positifs.</p>
<p>Deuxièmement, même si nous faisons tout pour l’éviter, il arrive parfois que des émetteurs en double émettent des signaux en même temps. Lorsque sont déployés en même temps deux émetteurs ayant le même identifiant, la même cadence d’émission et la même fréquence d’émission nominale, il se peut que les signaux captés proviennent de l’un ou de l’autre des émetteurs. Si cela se produit, il faut s’appuyer sur l’information contextuelle pour les départager (si possible). Les signaux en question sont appelés signaux d’émetteurs ambigus.</p>
<p>Troisièmement, il peut arriver que deux émetteurs diffusent chacun un signal en même temps et, ce faisant, produisent par hasard un signal semblant provenir d’un troisième émetteur, qui est en fait inexistant. Cette situation survient la plupart du temps à des sites de repos d’oiseaux ou dans des colonies de nidification, où de nombreux émetteurs fonctionnent simultanément. Dans ces cas, on qualifie ces émetteurs de faux. Il n’est pas expressément question des faux émetteurs dans le présent chapitre; nous cherchons une façon de les détecter de manière globale et d’éliminer les données qui s’y rapportent. Il en est question ici parce que vous pourriez rencontrer des situations où des données de détection semblent très plausibles sans pourtant avoir de sens sur le plan biologique. Communiquez avec nous si vous croyez qu’il existe des données de détection de signaux de faux émetteurs dans votre base.</p>
<p><em>Le présent chapitre a pour but</em> de vous fournir les outils dont vous avez besoin pour trouver les détections erronées dans vos données et les éliminer. Nous vous donnons ci-après des exemples de flux de travail permettant de traiter les faux positifs et les signaux d’émetteurs ambigus:</p>
<ol style="list-style-type: decimal">
<li><p>Utiliser un filtre préliminaire pour supprimer toutes les détections faisant partie d’une séquence d’au moins 2. Une séquence est un groupe de détections consécutives des signaux d’un émetteur par une antenne et un récepteur donnés. En général, le risque est élevé qu’une séquence d’au moins 2 détections (c.-à-d. 2 salves d’impulsions) représente un faux positif. Nous recommandons généralement d’éliminer toutes les détections faisant partie d’une séquence d’au moins 2, sauf si celles-ci ont eu lieu à l’une de quelques stations «tranquilles» où il y a peu de bruit radioélectrique. Toutefois, comme il est probable que cette opération entraîne la perte de détections non erronées, nous recommandons également qu’après avoir effectué une analyse complète de vos données, vous réexaminiez les détections en cause une à une pour déterminer (habituellement selon le contexte) si elles peuvent être considérées comme acceptables.</p></li>
<li><p>Déterminer combien de vos détections d’émetteurs peuvent être des détections de signaux ambigus.</p></li>
<li><p>Fournir un flux de travail pour examiner les détections individuellement et déterminer si elles font partie d’une séquence d’au moins 2 et si elles correspondent à des erreurs.</p></li>
<li><p>Éliminer les erreurs dans vos données.</p></li>
</ol>
<div id="chargement-des-logiciels-requis" class="section level2">
<h2><span class="header-section-number">5.1</span> Chargement des logiciels requis</h2>
<p>Suivez les instructions dans le chapitre <a href="loadingPackages.html#loadingPackages">2</a> pour installer les logiciels suivants avant de charger les données, si cela n’est pas déjà fait.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Sys.setenv</span>(<span class="dt">tz =</span> <span class="st">&quot;GMT&quot;</span>)

<span class="co"># library(devtools)</span>
<span class="kw">library</span>(motus)
<span class="kw">library</span>(tidyverse)
<span class="kw">library</span>(lubridate)
<span class="co"># library(rworldmap) # pour la production de cartes</span></code></pre></div>
</div>
<div id="chargement-des-donnees-de-detection" class="section level2">
<h2><span class="header-section-number">5.2</span> Chargement des données de détection</h2>
<p>Il est indiqué au chapitre <a href="accessingData.html#accessingData">3</a> que pour accéder à la base de données du projet 176 (données du Programme de suivi des oiseaux de rivage de la baie James), il faut entrer «motus.sample» dans la console R comme nom d’utilisateur et mot de passe à l’invite de la fonction tagme() du processus d’authentification de l’utilisateur. Nous tenons pour acquis que vous avez déjà effectué le téléchargement initial de ces données.</p>
<p>En accédant à la table alltags, nous supprimons certaines variables non nécessaires pour réduire la taille globale de l’ensemble de données et rendre son utilisation plus facile. <strong>C’est particulièrement important dans le cas des projets de grande envergure et complexes</strong>; la section <a href="accessingData.html#convertToFlat">3.7</a> présente la marche à suivre pour visualiser les variables dans une table et pour filtrer les données et en faire des sous-ensembles avant de les réunir dans une trame de données. Nous créons ensuite les variables de latitude et de longitude des récepteurs («recvLat», «recvLon», «recvAlt») en nous basant sur les coordonnées enregistrées par leur GPS («gpsLat», «gpsLon», «gpdAlt»). Lorsque ces coordonnées ne sont pas disponibles, il faut utiliser celles qui sont contenues dans les métadonnées sur les récepteurs déployés («recvDeployLat», «recvDeployLon», «recvDeployAlt»). Nous utilisons les instructions «collect()» et «as.data.frame()» pour transformer la trame de données en un fichier «plat» puis nous transformons toutes les variables temporelles exprimées en secondes depuis le 1er janvier 1970 dans le format de type datetime (POSIXct). Enfin, nous créons des noms de récepteurs («receiver names») à partir des variables de latitude et de longitude propres aux récepteurs dans la base de données pour lesquels les valeurs de ces variables ne sont pas inscrites.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">proj.num &lt;-<span class="st"> </span><span class="dv">176</span>

<span class="co"># Charger les données de détection, choisir les variables, créer des variables de latitude et transformer </span>
<span class="co"># la trame de données en un fichier plat. De plus, nous intervenons pour les sites dont les données sur les récepteurs déployés </span>
<span class="co"># sont manquantes ou dont les récepteurs n&#39;ont pas de nom. Quand plus d&#39;utilisateurs auront examiné (et corrigé!) leurs métadonnées, </span>
<span class="co"># il devrait commencer à y avoir moins de données manquantes.</span>
sql.motus &lt;-<span class="st"> </span><span class="kw">tagme</span>(proj.num, <span class="dt">update =</span> <span class="ot">TRUE</span>, <span class="dt">dir =</span> <span class="st">&quot;./data/&quot;</span>)
tbl.alltags &lt;-<span class="st"> </span><span class="kw">tbl</span>(sql.motus, <span class="st">&quot;alltags&quot;</span>)

df.alltags &lt;-<span class="st"> </span>tbl.alltags <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">recvLat =</span> <span class="kw">if_else</span>((<span class="kw">is.na</span>(gpsLat)<span class="op">|</span>gpsLat <span class="op">==</span><span class="st"> </span><span class="dv">0</span>), 
                           recvDeployLat, gpsLat), 
         <span class="dt">recvLon =</span> <span class="kw">if_else</span>((<span class="kw">is.na</span>(gpsLon)<span class="op">|</span>gpsLon <span class="op">==</span><span class="st"> </span><span class="dv">0</span>), 
                           recvDeployLon, gpsLon), 
         <span class="dt">recvAlt =</span> <span class="kw">if_else</span>(<span class="kw">is.na</span>(gpsAlt), recvDeployAlt, gpsAlt)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>noise, <span class="op">-</span>slop, <span class="op">-</span>burstSlop, <span class="op">-</span>done, <span class="op">-</span>bootnum, <span class="op">-</span>mfgID, 
         <span class="op">-</span>codeSet, <span class="op">-</span>mfg, <span class="op">-</span>nomFreq, <span class="op">-</span>markerNumber, <span class="op">-</span>markerType, 
         <span class="op">-</span>tagDeployComments, <span class="op">-</span>fullID, <span class="op">-</span>deviceID, <span class="op">-</span>recvDeployLat, 
         <span class="op">-</span>recvDeployLon, <span class="op">-</span>recvDeployAlt, <span class="op">-</span>speciesGroup, <span class="op">-</span>gpsLat, 
         <span class="op">-</span>gpsLon, <span class="op">-</span><span class="st"> </span>recvAlt, <span class="op">-</span><span class="st"> </span>recvSiteName) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">collect</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">as.data.frame</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">ts =</span> <span class="kw">as_datetime</span>(ts), <span class="co"># Travailler avec les dates APRÈS avoir transformé la trame de données en un fichier plat.</span>
         <span class="dt">tagDeployStart =</span> <span class="kw">as_datetime</span>(tagDeployStart),
         <span class="dt">tagDeployEnd =</span> <span class="kw">as_datetime</span>(tagDeployEnd), 
         <span class="dt">recvLat =</span> plyr<span class="op">::</span><span class="kw">round_any</span>(recvLat, <span class="fl">0.05</span>),
         <span class="dt">recvLon =</span> plyr<span class="op">::</span><span class="kw">round_any</span>(recvLon, <span class="fl">0.05</span>),
         <span class="dt">recvDeployName =</span> <span class="kw">if_else</span>(<span class="kw">is.na</span>(recvDeployName), 
                                  <span class="kw">paste</span>(recvLat, recvLon, <span class="dt">sep=</span><span class="st">&quot;:&quot;</span>), 
                                  recvDeployName))

<span class="co"># Notez que dans l&#39;instruction «select», vous pouvez simplement choisir les variables dont vous avez besoin,</span>
<span class="co"># par exemple select(runID, ts, sig, freqsd, motusTagID, ambigID, runLen, tagProjID, </span>
<span class="co">#              tagDeployStart, tagDeployEnd, etc.)</span></code></pre></div>
</div>
<div id="verifications-preliminaires-des-donnees" class="section level2">
<h2><span class="header-section-number">5.3</span> Vérifications préliminaires des données</h2>
<p>Avant de filtrer les données, il faut produire quelques sommaires et graphiques de données.</p>
<div id="sommaires-de-donnees-de-detection-demetteurs" class="section level3">
<h3><span class="header-section-number">5.3.1</span> Sommaires de données de détection d’émetteurs</h3>
<p>Premièrement, déterminez quels émetteurs ont été détectés et combien sont caractérisés par une séquence d’au moins 2 détections. Il y a plusieurs raisons pour lesquelles il se peut que des émetteurs déployés ne soient pas détectés:</p>
<ol style="list-style-type: decimal">
<li><p>L’émetteur n’a pas été activé correctement au moment du déploiement. Pour éviter cela, il faut toujours s’assurer que l’émetteur est activé en utilisant un récepteur portatif pour vérifier l’émission avant de fixer l’émetteur sur l’animal et de remettre celui-ci en liberté.</p></li>
<li><p>Il se peut qu’un animal portant un émetteur activé correctement ne soit pas passé dans la zone de détection d’une station réceptrice. La conception des études comprenant l’installation des récepteurs à des endroits stratégiques en fonction des objectifs du projet peut augmenter la probabilité de détection des émetteurs.</p></li>
<li><p>S’il y a des métadonnées sur les émetteurs déployés qui sont manquantes ou incorrectes dans la base de données Motus, il se peut que l’algorithme de traitement des données ne «voie» pas les émetteurs en question au moment où ils ont été déployés, ou à quelque moment que ce soit. Il faut s’assurer que les métadonnées sur les émetteurs sont entrées correctement.</p></li>
</ol>
<p>Avant de poursuivre, <strong>vérifiez si vous avez des émetteurs qui ont été déployés plus d’une fois</strong>, tel que décrit dans la section <a href="deployments.html#checkNumberTagDeployments">4.3.4</a>. Si c’est le cas, vous devrez utiliser «tagDeployID» ou une combinaison de «motusTagID» et de «tagDeployID» pour distinguer les détections propres à chaque déploiement (l’un ou l’autre des identifiants d’émetteurs peut faire l’affaire, mais en les combinant, vous saurez quel identifiant est associé à chaque déploiement).</p>
<p>Dans le projet 176, tous les émetteurs ont été déployés seulement une fois chacun. Nous utiliserons donc «motusTagID» comme identifiant unique pour un émetteur déployé dans tout le code R tout au long du présent guide.</p>
<p>L’opération suivante montre que 18 émetteurs déployés dans le cadre du projet 176 ont été détectés et que beaucoup sont caractérisés par une séquence d’au moins 2 détections (TRUE):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df.alltags <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">filter</span>(tagProjID <span class="op">==</span><span class="st"> </span>proj.num) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># sous-ensemble devant inclure seulement les émetteurs enregistrés dans le cadre du projet</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">rl.gt.2 =</span> runLen <span class="op">==</span><span class="st"> </span><span class="dv">2</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">group_by</span>(motusTagID, rl.gt.<span class="dv">2</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">tally</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">spread</span>(<span class="dt">key =</span> rl.gt.<span class="dv">2</span>, <span class="dt">value=</span>n)</code></pre></div>
<pre><code>## # A tibble: 18 x 3
## # Groups:   motusTagID [18]
##    motusTagID `FALSE` `TRUE`
##  *      &lt;int&gt;   &lt;int&gt;  &lt;int&gt;
##  1      16011     125      2
##  2      16035     454      2
##  3      16036     106     12
##  4      16037    1307     46
##  5      16038      84     78
##  6      16039    1098     28
##  7      16044     289     16
##  8      16047     773     66
##  9      16048      84     14
## 10      16052     133     26
## 11      17357     277     12
## 12      19129     568    720
## 13      22867    5545    222
## 14      22897   34308    488
## 15      22902    2815    108
## 16      22905   25684    326
## 17      23316    5518    216
## 18      23319   22471    288</code></pre>
<p>Dans certains cas, il peut s’agir de détections valides, mais nous jugeons qu’il est plus simple de les retirer de l’analyse, pour y revenir éventuellement. Nous filtrons donc en fonction d’une séquence de détections (runLen) supérieure à 2 pour la plupart des opérations subséquentes. Enregistrons les données filtrées dans un bloc pour l’ajouter à nos autres filtres plus tard.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df.alltags.sub &lt;-<span class="st"> </span><span class="kw">filter</span>(df.alltags, runLen <span class="op">&gt;</span><span class="st"> </span><span class="dv">2</span>)

df.block.<span class="dv">0</span> &lt;-<span class="st"> </span><span class="kw">filter</span>(df.alltags, runLen <span class="op">==</span><span class="st"> </span><span class="dv">2</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(motusTagID, 
    runID) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">distinct</span>()</code></pre></div>
<p>La meilleure façon d’obtenir une première représentation des données consiste à les pointer sous forme de graphiques. Nous vous montrerons plus tard comment pointer les données de détection sur une carte, mais nous préférons adopter d’abord une approche plus simple, soit le pointage selon la latitude et la longitude. Toutefois, il faut d’abord simplifier les données. Autrement, nous risquerions de tenter de répartir des milliers ou des millions de points, ce qui peut prendre beaucoup de temps. Nous simplifierons les données en créant une petite fonction qui nous servira de nouveau à de futures étapes.</p>
<p>Notez qu’il faut enlever environ 150 détections qu’il est impossible de localiser parce qu’il n’y a aucune référence géographique associée aux métadonnées sur les récepteurs qui ont capté les signaux. Faites une simple vérification pour déterminer si les récepteurs en cause vous appartiennent; dans l’affirmative, <strong>vous devez corriger les métadonnées en ligne</strong>!</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">filter</span>(df.alltags.sub, <span class="kw">is.na</span>(recvLat)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(recvLat, 
    recvLon, recvDeployName, recvDeployID, recv, recvProjID, 
    recvProjName) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">distinct</span>()</code></pre></div>
<pre><code>##   recvLat recvLon recvDeployName recvDeployID            recv recvProjID
## 1      NA      NA      NP mobile         3813       Lotek-280        176
## 2      NA      NA          NA:NA           NA SG-1415BBBK0382         NA
## 3      NA      NA          NA:NA           NA SG-2814BBBK0547         NA
##   recvProjName
## 1   SampleData
## 2         &lt;NA&gt;
## 3         &lt;NA&gt;</code></pre>
<p><strong>Simplification des données en vue du pointage</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Simplifiez les données en produisant un sommaire en fonction du runID. </span>
<span class="co"># Si vous voulez produire un sommaire à une échelle plus fine ou plus grossière, vous pouvez aussi créer d&#39;autres groupes.  </span>
<span class="co"># L&#39;option de rechange la plus simple est une variable d&#39;estampille temporelle arrondie; par exemple en utilisant</span>
<span class="co"># l&#39;appel de fonction mutate(ts.h = plyr::round_any(ts, 3600). </span>
<span class="co"># Une autre option consiste à utiliser juste la date (p. ex. date = as_date(ts)).</span>

<span class="co"># </span>
fun.getpath &lt;-<span class="st"> </span><span class="cf">function</span>(df) 
  {
  df <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">filter</span>(tagProjID <span class="op">==</span><span class="st"> </span>proj.num, <span class="co"># Conservez seulement les émetteurs enregistrés dans le cadre du projet 176.</span>
           <span class="op">!</span><span class="kw">is.na</span>(recvLat) <span class="op">|</span><span class="st"> </span><span class="op">!</span>(recvLat <span class="op">==</span><span class="st"> </span><span class="dv">0</span>)) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># Rejette les données sans indication de longitude/latitude</span>
<span class="st">    </span><span class="kw">group_by</span>(motusTagID, runID, recvDeployName, ambigID, 
             tagDeployLon, tagDeployLat, recvLat, recvLon) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="co"># Production d&#39;un sommaire par runID pour obtenir la séquence de détections maximale et la référence (estampille) temporelle moyenne:</span>
<span class="st">    </span><span class="kw">summarize</span>(<span class="dt">max.runLen =</span> <span class="kw">max</span>(runLen), <span class="dt">ts.h =</span> <span class="kw">mean</span>(ts)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">arrange</span>(motusTagID, ts.h)
  } <span class="co"># Fin de l&#39;appel de fonction</span>

df.alltags.path &lt;-<span class="st"> </span><span class="kw">fun.getpath</span>(df.alltags.sub)</code></pre></div>
<p>Nous commencerions par localiser un sous-ensemble d’émetteurs en fonction de la latitude ou de la longitude afin d’avoir un aperçu des problèmes possibles. Ici, pour simplifier l’exemple, nous pointons la position de seulement six émetteurs. Pour l’instant, nous évitons d’examiner les émetteurs ambigus.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> <span class="kw">filter</span>(df.alltags.path, motusTagID <span class="op">%in%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">c</span>(<span class="dv">16011</span>, <span class="dv">16035</span>, <span class="dv">16036</span>, <span class="dv">16037</span>, <span class="dv">16038</span>, <span class="dv">16039</span>)), <span class="kw">aes</span>(ts.h, 
    recvLat))
p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_path</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme_bw</span>() <span class="op">+</span><span class="st"> </span><span class="kw">facet_wrap</span>(<span class="op">~</span>motusTagID, 
    <span class="dt">scales =</span> <span class="st">&quot;free&quot;</span>, <span class="dt">ncol =</span> <span class="dv">2</span>) <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">axis.text.x =</span> <span class="kw">element_text</span>(<span class="dt">angle =</span> <span class="dv">45</span>, 
    <span class="dt">vjust =</span> <span class="dv">1</span>, <span class="dt">hjust =</span> <span class="dv">1</span>))</code></pre></div>
<p><img src="FrMotusRBook_files/figure-html/plot1.5-1.png" width="672" /></p>
<p>Nous voyons tout de suite qu’il pourrait y avoir un problème, car la position indiquée de certains émetteurs est à environ 44 degrés de latitude en hiver, ce qui est possible mais non probable dans le cas des oiseaux visés par le Programme de suivi des oiseaux de rivage de la baie James (projet 176). Examinons ces émetteurs de plus près en vérifiant les séquences de détections dans la trame de données qui sont associées aux détections effectuées en décembre et en janvier.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">filter</span>(df.alltags.sub, <span class="kw">month</span>(ts) <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="dv">12</span>, <span class="dv">1</span>), motusTagID <span class="op">%in%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">c</span>(<span class="dv">16036</span>, <span class="dv">16038</span>, <span class="dv">16039</span>)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(recvDeployName, 
    <span class="kw">month</span>(ts), runLen) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">summarize</span>(<span class="dt">n =</span> <span class="kw">length</span>(ts), 
    <span class="dt">n.tags =</span> <span class="kw">length</span>(<span class="kw">unique</span>(motusTagID)))</code></pre></div>
<pre><code>## # A tibble: 2 x 5
## # Groups:   recvDeployName, month(ts) [?]
##   recvDeployName     `month(ts)` runLen     n n.tags
##   &lt;chr&gt;                    &lt;dbl&gt;  &lt;int&gt; &lt;int&gt;  &lt;int&gt;
## 1 Sable West Light 2        1.00      3     3      1
## 2 Swallowtail              12.0       3     6      2</code></pre>
<p>Ces détections correspondent à des positions dans les Provinces maritimes du Canada (l’île de Sable, en Nouvelle-Écosse, et l’île Grand Manan, au Nouveau-Brunswick) et sont caractérisées par des séquences de 3 détections. Elles indiquent la présence probable de faux positifs. Commençons un compte des séquences précises en cause afin de les réunir pour effectuer un filtrage plus tard.</p>
<p>Si cela vous intéresse, vous pouvez exécuter de nouveau le code ci-dessus, mais avec la trame de données complète (df.alltags) contenant des séquences d’au moins 2 détections. Vous constaterez qu’il existe à ces positions d’autres détections de faux positifs qui sont déjà éliminées par filtrage en fonction d’une séquence d’au moins 2 détections (runLen &gt; 2). Ces détections supplémentaires montrent une nouvelle fois qu’il y avait du bruit radioélectrique à ces positions pendant ces mois précis (décembre et janvier), ce qui a causé certaines détections de faux positifs.</p>
<p>Vous pourriez aussi être intéressés d’une manière plus générale à déterminer quelles données sont caractérisées seulement par de courtes séquences de détections. Par exemple, le code suivant indique la séquence de détections maximale à tous les sites par mois (pour les séquences d’au moins 2 détections [runLen &gt; 2]).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df.alltags.sub <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(<span class="dt">month =</span> <span class="kw">month</span>(ts)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(recvDeployName, 
    month) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">summarize</span>(<span class="dt">max.rl =</span> <span class="kw">max</span>(runLen)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">spread</span>(<span class="dt">key =</span> month, <span class="dt">value =</span> max.rl)</code></pre></div>
<pre><code>## # A tibble: 49 x 9
## # Groups:   recvDeployName [49]
##    recvDeployName            `1`   `3`   `4`   `5`   `8`   `9`  `10`  `12`
##  * &lt;chr&gt;                   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 Assateague State Park      NA    NA    NA NA       NA  6.00 NA       NA
##  2 BennettMeadow              NA    NA    NA NA       NA NA    11.0     NA
##  3 Binbrook_Conservation_…    NA    NA    NA  3.00    NA NA    NA       NA
##  4 BISE                       NA    NA    NA NA       NA NA     6.00    NA
##  5 Bombay Hook                NA    NA    NA NA       NA 53.0  NA       NA
##  6 Brier2                     NA    NA    NA NA       NA 29.0  NA       NA
##  7 BSC HQ                     NA    NA    NA 21.0     NA NA    NA       NA
##  8 BULL                       NA    NA    NA NA       NA 38.0   5.00    NA
##  9 Comeau (Marshalltown)      NA    NA    NA NA       NA  4.00 NA       NA
## 10 CONY                       NA    NA    NA NA       NA NA     7.00    NA
## # ... with 39 more rows</code></pre>
<p>Vous pouvez aussi produire une liste des sites où la séquence de détections maximale ne dépasse jamais 4 (par exemple), ce qui peut parfois (mais pas toujours!) indiquer qu’il s’agit simplement de faux positifs.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df.alltags.sub <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(<span class="dt">month =</span> <span class="kw">month</span>(ts)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(recvDeployName, 
    month) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">summarize</span>(<span class="dt">max.rl =</span> <span class="kw">max</span>(runLen)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">filter</span>(max.rl <span class="op">&lt;</span><span class="st"> </span><span class="dv">5</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">spread</span>(<span class="dt">key =</span> month, <span class="dt">value =</span> max.rl)</code></pre></div>
<pre><code>## # A tibble: 12 x 8
## # Groups:   recvDeployName [12]
##    recvDeployName               `1`   `3`   `4`   `5`   `9`  `10`  `12`
##  * &lt;chr&gt;                      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 Binbrook_Conservation_Area NA    NA    NA     3.00 NA    NA    NA   
##  2 Comeau (Marshalltown)      NA    NA    NA    NA     4.00 NA    NA   
##  3 Koffler                    NA    NA     3.00 NA    NA    NA    NA   
##  4 LLICALDAD                  NA     4.00 NA    NA    NA    NA    NA   
##  5 MountToby                  NA    NA    NA    NA    NA     3.00 NA   
##  6 NP mobile                  NA    NA    NA    NA     3.00 NA    NA   
##  7 Old Cut                    NA    NA     4.00 NA    NA    NA    NA   
##  8 OSCT                       NA    NA    NA    NA    NA     3.00 NA   
##  9 Quempillen (Chile)         NA     3.00 NA    NA    NA    NA    NA   
## 10 Sable West Light 2          3.00 NA    NA    NA    NA    NA    NA   
## 11 Swallowtail                NA    NA    NA    NA    NA    NA     3.00
## 12 TRUS                       NA    NA    NA    NA    NA     4.00 NA</code></pre>
<p>Il est impossible de passer en revue ici tous les problèmes possibles. Nous vous encourageons fortement à explorer vos données minutieusement avant de prendre des décisions éclairées quant à savoir quelles détections sont improbables ou indéterminées. Dans le reste du présent chapitre, nous vous montrerons comment recueillir l’information sur les séquences de détections et les appliquer à vos données avant l’analyse.</p>
<p>Pour commencer, créons une trame de données contenant les motusTagID et les runID correspondant aux faux positifs indiqués précédemment.</p>
<p>Ensuite, produisons de nouveau le graphique avec les données nouvellement filtrées.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Créez le filtre.</span>
df.block.<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">filter</span>(df.alltags.sub, <span class="kw">month</span>(ts) <span class="op">%in%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">c</span>(<span class="dv">12</span>, <span class="dv">1</span>), motusTagID <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="dv">16036</span>, <span class="dv">16038</span>, <span class="dv">16039</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">select</span>(motusTagID, runID) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">distinct</span>()

<span class="co"># Utilisez la fonction que nous avons créée</span>
<span class="co"># précédemment pour produire une nouvelle trame de</span>
<span class="co"># données «path» en vue de créer le graphique.</span>
df.alltags.path &lt;-<span class="st"> </span><span class="kw">fun.getpath</span>(<span class="kw">filter</span>(df.alltags.sub, 
    motusTagID <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="dv">16011</span>, <span class="dv">16035</span>, <span class="dv">16036</span>, <span class="dv">16037</span>, <span class="dv">16038</span>, 
        <span class="dv">16039</span>), <span class="op">!</span>(runID <span class="op">%in%</span><span class="st"> </span>df.block.<span class="dv">1</span><span class="op">$</span>runID)))

p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> df.alltags.path, <span class="kw">aes</span>(ts.h, recvLat))
p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_path</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme_bw</span>() <span class="op">+</span><span class="st"> </span><span class="kw">facet_wrap</span>(<span class="op">~</span>motusTagID, 
    <span class="dt">scales =</span> <span class="st">&quot;free&quot;</span>, <span class="dt">ncol =</span> <span class="dv">2</span>) <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">axis.text.x =</span> <span class="kw">element_text</span>(<span class="dt">angle =</span> <span class="dv">45</span>, 
    <span class="dt">vjust =</span> <span class="dv">1</span>, <span class="dt">hjust =</span> <span class="dv">1</span>))</code></pre></div>
<p><img src="FrMotusRBook_files/figure-html/createRunsFilter1-1.png" width="672" /></p>
<p>Nous pouvons voir que la majorité des détections qui restent semblent maintenant avoir plus de sens. Les émetteurs 16035, 16037 et 16039 ont été détectés pendant la migration dans ce qui semble être une progression latitudinale raisonnable dans le temps, et les trois autres émetteurs n’ont pas été détectés très loin du lieu de leur déploiement.</p>
<p>Nous vous encourageons à explorer le reste des émetteurs dans ce groupe pour déterminer s’il y a d’autres faux positifs.</p>
</div>
</div>
<div id="ambigs" class="section level2">
<h2><span class="header-section-number">5.4</span> Recherche et examen de détections ambiguës</h2>
<p>Avant d’aller plus loin, nous devons vérifier s’il y a des détections ambiguës d’émetteurs. S’il y en a, nous devons les examiner et créer d’autres filtres pour les éliminer de notre base de données.</p>
<p><strong>Est-ce que vous avez des émetteurs associés à des détections ambiguës?</strong></p>
<p>La fonction «clarify()» du logiciel R motusClient permet de produire un sommaire des ambiguïtés dans les données de détection. Chaque ambigID se rapporte à une sélection de détections qui pourraient correspondre à au moins un motusTagID (jusqu’à concurrence de 6), lesquels sont indiqués dans les champs id1 à id6:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">clarify</span>(sql.motus)</code></pre></div>
<pre><code>##   ambigID numHits   id1                              fullID1   id2
## 1     -56    5734 22867 SampleData#272.1:5.3@166.38(M.22867) 23316
## 2    -106     279 17021        Selva#172:6.1@166.38(M.17021) 17357
## 3    -114      86 22897 SampleData#303.1:5.3@166.38(M.22897) 24298
## 4    -134   22749 22905   SampleData#301:5.3@166.38(M.22905) 23319
## 5    -171    2074 22778   RBrownAMWO#308:5.3@166.38(M.22778) 22902
## 6    -337       4 10811        Niles#152:6.1@166.38(M.10811) 16011
##                                fullID2   id3
## 1   SampleData#272:5.3@166.38(M.23316)    NA
## 2   SampleData#172:6.1@166.38(M.17357)    NA
## 3      NEONICS#303:5.3@166.38(M.24298)    NA
## 4 SampleData#301.1:5.3@166.38(M.23319)    NA
## 5 SampleData#308.1:5.3@166.38(M.22902) 24303
## 6   SampleData#152:6.1@166.38(M.16011)    NA
##                           fullID3 id4 fullID4 id5 fullID5 id6 fullID6
## 1                            &lt;NA&gt;  NA    &lt;NA&gt;  NA    &lt;NA&gt;  NA    &lt;NA&gt;
## 2                            &lt;NA&gt;  NA    &lt;NA&gt;  NA    &lt;NA&gt;  NA    &lt;NA&gt;
## 3                            &lt;NA&gt;  NA    &lt;NA&gt;  NA    &lt;NA&gt;  NA    &lt;NA&gt;
## 4                            &lt;NA&gt;  NA    &lt;NA&gt;  NA    &lt;NA&gt;  NA    &lt;NA&gt;
## 5 NEONICS#308:5.3@166.38(M.24303)  NA    &lt;NA&gt;  NA    &lt;NA&gt;  NA    &lt;NA&gt;
## 6                            &lt;NA&gt;  NA    &lt;NA&gt;  NA    &lt;NA&gt;  NA    &lt;NA&gt;
##   motusTagID tsStart tsEnd
## 1         NA      NA    NA
## 2         NA      NA    NA
## 3         NA      NA    NA
## 4         NA      NA    NA
## 5         NA      NA    NA
## 6         NA      NA    NA</code></pre>
<p>Nous pouvons voir qu’il y a dans cet ensemble de données six émetteurs associés à des détections ambiguës. Les détections associées à cinq des six «ambigID» pourraient correspondre à un de deux émetteurs et celles associées à un «ambigID» (-171), à un de trois émetteurs. Les champs «fullID» indiquent les noms des projets associés aux émetteurs en double (p. ex., «SampleData», «Selva» et «Niles»), ainsi que les caractéristiques des émetteurs (identifiant du fabricant, cadence d’émission et fréquence d’émission).</p>
<p>Obtenons un vecteur et produisons des graphiques pour voir où il pourrait y avoir des problèmes.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df.ambigTags &lt;-<span class="st"> </span><span class="kw">select</span>(df.alltags.sub, ambigID, motusTagID) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">filter</span>(<span class="op">!</span><span class="kw">is.na</span>(ambigID)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">distinct</span>()</code></pre></div>
<p>En utilisant notre fonction «getpath», nous créerons des trajectoires et nous pointerons les détections sur des graphiques. Nous ajouterons de l’information dans les graphiques pour indiquer où (dans le temps) les émetteurs sont effectivement ambigus. Nous pourrons alors inspecter l’ensemble (ou des parties) de chaque graphique pour déterminer si nous pouvons attribuer sans ambiguïté selon le contexte la détection d’un émetteur ambigu à un déploiement particulier.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df.alltags.path &lt;-<span class="st"> </span><span class="kw">fun.getpath</span>(<span class="kw">filter</span>(df.alltags.sub, 
    motusTagID <span class="op">%in%</span><span class="st"> </span>df.ambigTags<span class="op">$</span>motusTagID, tagProjID <span class="op">==</span><span class="st"> </span>
<span class="st">        </span>proj.num)) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># Créez une variable booléenne pour les détections</span>
<span class="co"># ambiguës:</span>
<span class="kw">mutate</span>(<span class="dt">Ambiguous =</span> <span class="op">!</span>(<span class="kw">is.na</span>(ambigID)))

<span class="co"># Pour pointer tous les émetteurs ambigus se</span>
<span class="co"># rapportant à un même projet ensemble sur le même</span>
<span class="co"># graphique, nous devons créer une nouvelle</span>
<span class="co"># variable «ambig tag» que nous appelons «newID»</span>

ambigTags.<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">filter</span>(df.alltags.sub) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(ambigID, 
    motusTagID) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(<span class="op">!</span><span class="kw">is.na</span>(ambigID)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">distinct</span>() <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">group_by</span>(ambigID) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">summarize</span>(<span class="dt">newID =</span> <span class="kw">paste</span>(<span class="kw">unique</span>(ambigID), 
    <span class="kw">toString</span>(motusTagID), <span class="dt">sep =</span> <span class="st">&quot;: &quot;</span>)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">left_join</span>(df.ambigTags, 
    <span class="dt">by =</span> <span class="st">&quot;ambigID&quot;</span>)

<span class="co"># et la fusionner avec «df.alltags.path».</span>
df.alltags.path &lt;-<span class="st"> </span><span class="kw">left_join</span>(df.alltags.path, ambigTags.<span class="dv">2</span>, 
    <span class="dt">by =</span> <span class="st">&quot;motusTagID&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">arrange</span>(ts.h)

p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> df.alltags.path, <span class="kw">aes</span>(ts.h, recvLat, 
    <span class="dt">group =</span> Ambiguous, <span class="dt">colour =</span> Ambiguous))
p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_path</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme_bw</span>() <span class="op">+</span><span class="st"> </span><span class="kw">facet_wrap</span>(<span class="op">~</span>newID, 
    <span class="dt">scales =</span> <span class="st">&quot;free&quot;</span>, <span class="dt">ncol =</span> <span class="dv">2</span>) <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">axis.text.x =</span> <span class="kw">element_text</span>(<span class="dt">angle =</span> <span class="dv">45</span>, 
    <span class="dt">vjust =</span> <span class="dv">1</span>, <span class="dt">hjust =</span> <span class="dv">1</span>))</code></pre></div>
<p><img src="FrMotusRBook_files/figure-html/plotAmbigs-1.png" width="672" /></p>
<p>Occupons-nous d’abord des cas faciles.</p>
<p><strong>ambigID -337: motusTagID 10811 et 16011</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">filter</span>(df.alltags.sub, ambigID <span class="op">==</span><span class="st"> </span><span class="op">-</span><span class="dv">337</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(motusTagID, 
    tagDeployStart, tagDeployEnd, tagDeployLat, tagDeployLon) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">tally</span>()</code></pre></div>
<pre><code>## # A tibble: 2 x 6
## # Groups:   motusTagID, tagDeployStart, tagDeployEnd, tagDeployLat [?]
##   motusTagID tagDeployStart      tagDeployEnd        tagDeployLat
##        &lt;int&gt; &lt;dttm&gt;              &lt;dttm&gt;                     &lt;dbl&gt;
## 1      10811 2014-10-28 07:00:00 2015-08-03 07:00:00         39.1
## 2      16011 2015-08-02 11:39:59 2015-12-17 11:39:59         51.5
## # ... with 2 more variables: tagDeployLon &lt;dbl&gt;, n &lt;int&gt;</code></pre>
<p>Le graphique montre que l’émetteur ambigu -337 est ambigu seulement au début du déploiement.</p>
<p>En examinant le sommaire des données sur les déploiements des émetteurs, nous constatons qu’il y avait seulement 4 détections, à la latitude exacte du déploiement de l’émetteur 16011 et juste avant les détections non ambiguës du motusTagID 16011. Dès lors, le problème ici est seulement que la queue de la trajectoire de déploiement de l’émetteur 10811 chevauche légèrement la trajectoire de déploiement de l’émetteur 16011. Nous pouvons affirmer en toute confiance que ces détections sont reliées au motusTagID 16011 et supprimer les détections ambiguës attribuées à l’autre émetteur.</p>
<p>Nous créerons une autre trame de données pour assurer le suivi de ces séquences de détections.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Nous voulons trouver les détections associées au</span>
<span class="co"># motusTagID que nous souhaitons ultimement</span>
<span class="co"># SUPPRIMER de la trame de données.</span>
df.block.<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">filter</span>(df.alltags.sub, ambigID <span class="op">==</span><span class="st"> </span><span class="op">-</span><span class="dv">337</span>, 
    motusTagID <span class="op">==</span><span class="st"> </span><span class="dv">10811</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(motusTagID, runID) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">distinct</span>()</code></pre></div>
<p><strong>ambigID -134: motusTagIDs 22905 et 23319</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">filter</span>(df.alltags.sub, ambigID <span class="op">==</span><span class="st"> </span><span class="op">-</span><span class="dv">134</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(motusTagID, 
    tagDeployStart, tagDeployEnd, tagDeployLat, tagDeployLon, 
    <span class="kw">month</span>(ts)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">tally</span>()</code></pre></div>
<pre><code>## # A tibble: 4 x 7
## # Groups:   motusTagID, tagDeployStart, tagDeployEnd, tagDeployLat,
## #   tagDeployLon [?]
##   motusTagID tagDeployStart      tagDeployEnd        tagDeployLat
##        &lt;int&gt; &lt;dttm&gt;              &lt;dttm&gt;                     &lt;dbl&gt;
## 1      22905 2016-10-01 16:00:00 2017-06-12 16:00:00         50.2
## 2      22905 2016-10-01 16:00:00 2017-06-12 16:00:00         50.2
## 3      23319 2016-10-15 16:00:00 2017-06-26 16:00:00         50.2
## 4      23319 2016-10-15 16:00:00 2017-06-26 16:00:00         50.2
## # ... with 3 more variables: tagDeployLon &lt;dbl&gt;, `month(ts)` &lt;dbl&gt;,
## #   n &lt;int&gt;</code></pre>
<p>Ici, la situation est semblable à la précédente, mais un peu plus complexe. Deux émetteurs identiques ont été déployés peu de temps l’un après l’autre au même endroit. Examinons un graphique simple.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">filter</span>(df.alltags.sub, motusTagID <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="dv">22905</span>, <span class="dv">23319</span>), 
    <span class="kw">month</span>(ts) <span class="op">==</span><span class="st"> </span><span class="dv">10</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(ts, sig, <span class="dt">group =</span> recvDeployName, 
    <span class="dt">colour =</span> recvDeployName)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme_bw</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">xlab</span>(<span class="st">&quot;Time&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">ylab</span>(<span class="st">&quot;Signal strength&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">facet_grid</span>(recvLon <span class="op">~</span><span class="st"> </span>
<span class="st">    </span>.)</code></pre></div>
<p><img src="FrMotusRBook_files/figure-html/ambig134b-1.png" width="672" /></p>
<p>Il semble que les détections à deux sites proches l’un de l’autre se chevauchent. De l’information supplémentaire fournie par les chercheurs sur le terrain pourrait nous permettre de dénouer l’intrigue, mais à la seule vue des données la situation n’est pas claire.</p>
<p>Nous examinons également les détections non ambiguës de l’émetteur -134 effectuées à la mi-avril. Comme c’est très tôt pour qu’un Bécasseau maubèche passe au-dessus du sud de l’Ontario, il y a lieu de s’interroger sur ces détections.</p>
<p>L’utilisation du filtre suivant révèle l’existence de deux séquences distinctes de 3 détections séparées par un intervalle de 3 jours. Si nous inspectons le reste de ce lot (c.-à-d. si nous examinons aussi les séquences d’au moins 2 détections dans la trame de données originale) …</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">filter</span>(df.alltags, batchID <span class="op">==</span><span class="st"> </span><span class="dv">79646</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(runLen, 
    recvDeployName) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(runLen, recvDeployName) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">tally</span>()</code></pre></div>
<pre><code>## # A tibble: 2 x 3
## # Groups:   runLen [?]
##   runLen recvDeployName     n
##    &lt;int&gt; &lt;chr&gt;          &lt;int&gt;
## 1      2 Koffler          110
## 2      3 Koffler           12</code></pre>
<p>… nous constatons qu’il y a beaucoup de faux positifs à cette tour à peu près au même moment (dans le même lot), de sorte que les séquences de 3 détections sont vraisemblablement de faux positifs. Nous supprimerons donc de la base de données toutes les détections de cet émetteur ambigu.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Nous voulons trouver les détections associées au</span>
<span class="co"># motusTagID que nous souhaitons ultimement</span>
<span class="co"># SUPPRIMER de la trame de données.</span>

df.block.<span class="dv">3</span> &lt;-<span class="st"> </span><span class="kw">filter</span>(df.alltags.sub, ambigID <span class="op">==</span><span class="st"> </span><span class="op">-</span><span class="dv">134</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">select</span>(motusTagID, runID) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">distinct</span>()</code></pre></div>
<p><strong>ambigID -171: motusTagIDs 22778, 22902 et 22403</strong></p>
<p>Les détections ambiguës reliées à cet émetteur, effectuées dans la région des Grands Lacs, pourraient aussi être reliées au motusTagID 22778 enregistré dans le cadre du projet RBrownAMWO ou au motusTagID 24303 enregistré dans le cadre du projet Neonics. Examinons ces détections de plus près.</p>
<p>Premièrement, trouvez la date et le lieu du déploiement de chaque émetteur.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">filter</span>(df.alltags, ambigID <span class="op">==</span><span class="st"> </span><span class="op">-</span><span class="dv">171</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(<span class="op">!</span><span class="kw">is.na</span>(tagDeployStart)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">select</span>(motusTagID, tagProjID, <span class="dt">start =</span> tagDeployStart, 
        <span class="dt">end =</span> tagDeployEnd, <span class="dt">lat =</span> tagDeployLat, <span class="dt">lon =</span> tagDeployLon, 
        <span class="dt">species =</span> speciesEN) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">distinct</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">arrange</span>(start)</code></pre></div>
<pre><code>##   motusTagID tagProjID               start                 end      lat
## 1      22902       176 2016-10-01 16:00:00 2017-06-12 16:00:00 50.19278
## 2      22778        82 2016-10-21 00:00:00 2018-09-09 00:00:00 45.13535
## 3      24303       146 2017-05-10 22:30:59 2017-06-30 22:30:59 42.60600
##         lon               species
## 1 -63.74528              Red Knot
## 2 -67.29323     American Woodcock
## 3 -80.46900 White-crowned Sparrow</code></pre>
<p>Et pointez sur des graphiques les détections ambiguës.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df.ambig.<span class="dv">171</span> &lt;-<span class="st"> </span><span class="kw">filter</span>(df.alltags.sub, ambigID <span class="op">==</span><span class="st"> </span><span class="op">-</span><span class="dv">171</span>)

p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> df.ambig.<span class="dv">171</span>, <span class="kw">aes</span>(ts, sig, <span class="dt">colour =</span> <span class="kw">as.factor</span>(port)))
p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_smooth</span>(<span class="dt">method =</span> <span class="st">&quot;loess&quot;</span>, <span class="dt">se =</span> <span class="ot">FALSE</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">theme_bw</span>() <span class="op">+</span><span class="st"> </span><span class="kw">facet_wrap</span>(<span class="kw">as_date</span>(ts) <span class="op">~</span><span class="st"> </span>recvDeployName, 
    <span class="dt">scales =</span> <span class="st">&quot;free_x&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">axis.text.x =</span> <span class="kw">element_text</span>(<span class="dt">angle =</span> <span class="dv">45</span>, 
    <span class="dt">vjust =</span> <span class="dv">1</span>, <span class="dt">hjust =</span> <span class="dv">1</span>))</code></pre></div>
<p><img src="FrMotusRBook_files/figure-html/ambig171b-1.png" width="672" /></p>
<p>Nous voyons qu’il y a un grand nombre de détections ambiguës le 10 mai 2017 à Old Cut (Long Point, lac Érié, Ontario), ce qui s’expliquerait par la présence d’un oiseau qui «flâne» dans les environs. Il s’agit presque certainement de détections des signaux de l’émetteur 24303, qui a été déployé à Old Cut le 10 mai 2017. Les détections ultérieures ont été effectuées le 18 mai près d’Old Cut (siège d’Études d’Oiseaux Canada, Port Rowan, Ontario) puis au nord d’Old Cut (Hagersville, Ontario). Ces détections correspondent au départ en migration d’un oiseau. Notez en particulier les courbes dans les graphiques du centre et de droite qui correspondent à une hausse puis une baisse de la puissance du signal, ce qui indiquerait qu’un oiseau passe en volant dans le faisceau d’une antenne.</p>
<p>Comme ces détections sont reliées à un autre projet, nous supprimons simplement toutes les détections de cet émetteur ambigu de notre base de données.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Nous voulons trouver les détections associées au</span>
<span class="co"># motusTagID que nous souhaitons ultimement</span>
<span class="co"># SUPPRIMER de la trame de données.</span>


df.block.<span class="dv">4</span> &lt;-<span class="st"> </span><span class="kw">filter</span>(df.alltags.sub, ambigID <span class="op">==</span><span class="st"> </span><span class="op">-</span><span class="dv">171</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">select</span>(motusTagID, runID) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">distinct</span>()</code></pre></div>
<p><strong>ambigID -114: motusTagIDs 22897 et 24298</strong></p>
<p>Examinons maintenant les ambiguïtés se rapportant à l’émetteur -114.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">filter</span>(df.alltags, ambigID <span class="op">==</span><span class="st"> </span><span class="op">-</span><span class="dv">114</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(<span class="op">!</span><span class="kw">is.na</span>(tagDeployStart)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">select</span>(motusTagID, tagProjID, <span class="dt">start =</span> tagDeployStart, 
        <span class="dt">end =</span> tagDeployEnd, <span class="dt">lat =</span> tagDeployLat, <span class="dt">lon =</span> tagDeployLon, 
        <span class="dt">species =</span> speciesEN) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">distinct</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">arrange</span>(start)</code></pre></div>
<pre><code>##   motusTagID tagProjID               start                 end      lat
## 1      22897       176 2016-10-01 16:00:00 2017-06-12 16:00:00 50.19278
## 2      24298       146 2017-05-10 03:00:00 2017-06-30 03:00:00 42.60690
##         lon               species
## 1 -63.74528              Red Knot
## 2 -80.46900 White-crowned Sparrow</code></pre>
<p>Ici encore, nous formons un sous-ensemble de données que nous pointons sur un graphique. Comme un premier graphique semble indiquer que toutes les détections se rapportent à un vol migratoire, nous produisons un graphique quelque peu différent du précédent qui illustre mieux cette situation.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df.ambig.<span class="dv">114</span> &lt;-<span class="st"> </span><span class="kw">filter</span>(df.alltags.sub, ambigID <span class="op">==</span><span class="st"> </span><span class="op">-</span><span class="dv">114</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">mutate</span>(<span class="dt">LatLonStationName =</span> <span class="kw">paste</span>(recvLat, recvLon, 
        recvDeployName, <span class="dt">sep =</span> <span class="st">&quot;: &quot;</span>))

p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> df.ambig.<span class="dv">114</span>, <span class="kw">aes</span>(ts, sig, <span class="dt">colour =</span> LatLonStationName))

p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme_bw</span>()</code></pre></div>
<p><img src="FrMotusRBook_files/figure-html/ambig114b-1.png" width="672" /></p>
<p>Notez que les détections correspondent à un départ en migration à partir du secteur de Long Point (station d’Old Cut, lac Érié, Ontario) environ une semaine après le déploiement de l’émetteur ambigu 24298 au même endroit. Dans ce cas aussi, il semble que les détections ambiguës peuvent être supprimées de la base de données car elles sont reliées à un autre projet.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df.block.<span class="dv">5</span> &lt;-<span class="st"> </span><span class="kw">filter</span>(df.alltags.sub, ambigID <span class="op">==</span><span class="st"> </span><span class="op">-</span><span class="dv">114</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">select</span>(motusTagID, runID) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">distinct</span>()</code></pre></div>
<p><strong>ambigID -106: motusTagIDs 17021 et 17357</strong></p>
<p>Ces deux émetteurs posent un problème intéressant. Il y a seulement une courte période de chevauchement, entre la mi-août et la mi-septembre 2015. Un des émetteurs a été fixé sur une Grive à joues grises en Colombie et l’autre sur un Bécasseau à croupion blanc, qui était associé au projet 176 (Programme de suivi des oiseaux de rivage de la baie James).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">filter</span>(df.alltags, ambigID <span class="op">==</span><span class="st"> </span><span class="op">-</span><span class="dv">106</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(<span class="op">!</span><span class="kw">is.na</span>(tagDeployStart)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">select</span>(motusTagID, tagProjID, <span class="dt">start =</span> tagDeployStart, 
        <span class="dt">end =</span> tagDeployEnd, <span class="dt">lat =</span> tagDeployLat, <span class="dt">lon =</span> tagDeployLon, 
        <span class="dt">species =</span> speciesEN) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">distinct</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">arrange</span>(start)</code></pre></div>
<pre><code>##   motusTagID tagProjID               start                 end      lat
## 1      17021        57 2015-04-30 05:00:00 2015-09-14 05:00:00 11.12265
## 2      17357       176 2015-08-11 07:20:00 2015-12-26 07:20:00 51.48390
##         lon                species
## 1 -74.08735    Gray-cheeked Thrush
## 2 -80.45000 White-rumped Sandpiper</code></pre>
<p>Nous pointons les détections ambiguës sur des graphiques pour examiner la période de chevauchement.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df.ambig.<span class="dv">106</span> &lt;-<span class="st"> </span><span class="kw">filter</span>(df.alltags.sub, ambigID <span class="op">==</span><span class="st"> </span><span class="op">-</span><span class="dv">106</span>)

p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> df.ambig.<span class="dv">106</span>, <span class="kw">aes</span>(ts, sig, <span class="dt">colour =</span> <span class="kw">paste</span>(recvLat, 
    recvLon, recvDeployName, <span class="dt">sep =</span> <span class="st">&quot;: &quot;</span>)))

p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">scale_colour_discrete</span>(<span class="dt">name =</span> <span class="st">&quot;Lat/Lon and</span><span class="ch">\n</span><span class="st">Station Name&quot;</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">theme_bw</span>() <span class="op">+</span><span class="st"> </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="kw">as_date</span>(ts), <span class="dt">scales =</span> <span class="st">&quot;free_x&quot;</span>)</code></pre></div>
<p><img src="FrMotusRBook_files/figure-html/ambig106b-1.png" width="672" /></p>
<p>Les séquences de détections sont longues dans les deux ensembles, qui semblent valides (hausse puis baisse de la puissance du signal). Les deux ensembles de détections sont séparés d’environ une journée; il se peut donc qu’ils correspondent à deux oiseaux différents ou encore au vol de départ du Bécasseau à croupion blanc depuis sa halte migratoire. Utilisons la fonction siteTrans (dans le logiciel motus; voir la section <a href="appendixC.html#siteTrans">C.13</a>) pour examiner le vol entre Netitishi et MDR/Seal (dans le golfe du Maine).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df.ambig.<span class="dv">106</span> <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(motusTagID <span class="op">==</span><span class="st"> </span><span class="dv">17021</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># Choisissez seulement l&#39;identifiant d&#39;un des deux émetteurs ambigus.</span>
<span class="kw">siteTrans</span>(<span class="dt">latCoord =</span> <span class="st">&quot;recvLat&quot;</span>, <span class="dt">lonCoord =</span> <span class="st">&quot;recvLon&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ungroup</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">filter</span>(rate <span class="op">&lt;</span><span class="st"> </span><span class="dv">60</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># Supprimez les détections simultanées des signaux provenant de Seal et de MDR.</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">total.time =</span> <span class="kw">as.numeric</span>(<span class="kw">round</span>(<span class="kw">seconds_to_period</span>(tot_ts)))) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="dt">start=</span>recvDeployName.x, <span class="dt">end=</span>recvDeployName.y, <span class="dt">date=</span>ts.x, <span class="st">&quot;rate(m/s)&quot;</span> =<span class="st"> </span>rate, 
         dist, <span class="dt">total.time =</span> total.time, bearing)</code></pre></div>
<pre><code>## # A tibble: 1 x 7
##   start   end    date                `rate(m/s)`   dist total.time bearing
##   &lt;chr&gt;   &lt;chr&gt;  &lt;dttm&gt;                    &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;   &lt;dbl&gt;
## 1 Netiti… MDR_4… 2015-09-02 04:18:42        17.1 1.21e⁶      70879     128</code></pre>
<p>Ces détections sont à plus de 1200 km l’une de l’autre, mais la vitesse du vol (17 m/s) correspond à celle d’un Bécasseau à croupion blanc. Étant donné que la durée de vie prévue de l’émetteur porté par la Grive à joues grises était proche de sa fin, nous pouvons raisonnablement affirmer que ces détections sont reliées au projet 176 et supprimer les détections ambiguës associées au motusTagID 17021.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df.block.<span class="dv">6</span> &lt;-<span class="st"> </span><span class="kw">filter</span>(df.alltags.sub, ambigID <span class="op">==</span><span class="st"> </span><span class="op">-</span><span class="dv">106</span>, 
    motusTagID <span class="op">==</span><span class="st"> </span><span class="dv">17021</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(motusTagID, runID) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">distinct</span>()</code></pre></div>
<p><strong>ambigID -56: motusTagIDs 22867 et 23316</strong></p>
<p>Ces deux émetteurs ont aussi été déployés dans le cadre du même projet.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">filter</span>(df.alltags, ambigID <span class="op">==</span><span class="st"> </span><span class="op">-</span><span class="dv">56</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(<span class="op">!</span><span class="kw">is.na</span>(tagDeployStart)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">select</span>(motusTagID, tagProjID, <span class="dt">start =</span> tagDeployStart, 
        <span class="dt">end =</span> tagDeployEnd, <span class="dt">lat =</span> tagDeployLat, <span class="dt">lon =</span> tagDeployLon, 
        <span class="dt">species =</span> speciesEN) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">distinct</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">arrange</span>(start)</code></pre></div>
<pre><code>##   motusTagID tagProjID               start                 end      lat
## 1      22867       176 2016-09-06 15:35:00 2017-05-18 15:35:00 51.79861
## 2      23316       176 2016-10-02 16:00:00 2017-06-13 16:00:00 50.19278
##         lon            species
## 1 -80.69139 Pectoral Sandpiper
## 2 -63.74528           Red Knot</code></pre>
<p>L’émetteur 23316 a été déployé dans le cadre du Programme de suivi des oiseaux de rivage de la baie James (projet 176) environ trois semaines après l’émetteur 22867, dont le lieu de déploiement se trouvait loin à l’ouest.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df.ambig.<span class="dv">56</span> &lt;-<span class="st"> </span><span class="kw">filter</span>(df.alltags.sub, ambigID <span class="op">==</span><span class="st"> </span><span class="op">-</span><span class="dv">56</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">mutate</span>(<span class="dt">sig =</span> <span class="kw">ifelse</span>(sig <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>, sig <span class="op">*</span><span class="st"> </span><span class="op">-</span><span class="dv">1</span>, sig))

p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> df.ambig.<span class="dv">56</span>, <span class="kw">aes</span>(recvLon, ts, <span class="dt">colour =</span> <span class="kw">paste</span>(recvLat, 
    recvLon, recvDeployName, <span class="dt">sep =</span> <span class="st">&quot;: &quot;</span>)))
p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme_bw</span>() <span class="op">+</span><span class="st"> </span><span class="kw">scale_colour_discrete</span>(<span class="dt">name =</span> <span class="st">&quot;Lat/Lon and</span><span class="ch">\n</span><span class="st">Station Name&quot;</span>)</code></pre></div>
<p><img src="FrMotusRBook_files/figure-html/ambig56b-1.png" width="672" /> Nous voyons sur le graphique qu’un émetteur est détecté constamment près de la longitude -65, près du lieu de déploiement de l’émetteur 23316. Après la date du début du déploiement, cet émetteur était également présent à -65 pendant et après les détections effectuées loin à l’ouest. Selon toute probabilité, toutes les détections effectuées à -65 se rapportent à l’émetteur 23316. Toutefois, il est également clair que l’explication de l’ambiguïté se trouve dans la période du 9 au 11 octobre, de sorte que nous devons nous concentrer sur cette partie de l’ensemble de données.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ts.begin &lt;-<span class="st"> </span><span class="kw">ymd_hms</span>(<span class="st">&quot;2016-10-06 00:00:00&quot;</span>)
ts.end &lt;-<span class="st"> </span><span class="kw">ymd_hms</span>(<span class="st">&quot;2016-10-12 23:00:00&quot;</span>)
p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> <span class="kw">filter</span>(df.ambig.<span class="dv">56</span>, ts <span class="op">&gt;</span><span class="st"> </span>ts.begin, 
    ts <span class="op">&lt;</span><span class="st"> </span>ts.end), <span class="kw">aes</span>(ts, recvLon, <span class="dt">colour =</span> <span class="kw">paste</span>(recvLat, 
    recvLon, recvDeployName, <span class="dt">sep =</span> <span class="st">&quot;: &quot;</span>)))
p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme_bw</span>() <span class="op">+</span><span class="st"> </span><span class="kw">scale_colour_discrete</span>(<span class="dt">name =</span> <span class="st">&quot;Lat/Lon and</span><span class="ch">\n</span><span class="st">Station Name&quot;</span>)</code></pre></div>
<p><img src="FrMotusRBook_files/figure-html/ambig56c-1.png" width="672" /></p>
<p>Nous pouvons constater que l’émetteur ambigu a été détecté constamment à Niapiskau et Grand Île avant et après la période durant laquelle il a aussi été détecté au nord et à l’ouest (à Washkaugou et à Piskwamish) et ensuite au sud (NBNJ, SHNJ et CONY). Nous pouvons examiner cette transition en filtrant la portion des détections non proches de Niapiskau et de nouveau en utilisant la fonction siteTrans du logiciel motus.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># L’autre émetteur est un double.</span>
df.<span class="fl">56.</span>tmp &lt;-<span class="st"> </span><span class="kw">filter</span>(df.ambig.<span class="dv">56</span>, <span class="op">!</span>(recvLat <span class="op">==</span><span class="st"> </span><span class="fl">50.2</span>), motusTagID <span class="op">==</span><span class="st"> </span><span class="dv">22867</span>) 

<span class="kw">siteTrans</span>(df.<span class="fl">56.</span>tmp, <span class="dt">latCoord =</span> <span class="st">&quot;recvLat&quot;</span>, <span class="dt">lonCoord =</span> <span class="st">&quot;recvLon&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ungroup</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">filter</span>(rate <span class="op">&lt;</span><span class="st"> </span><span class="dv">60</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># get rid of simultaneous detections</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">total.time =</span> <span class="kw">as.numeric</span>(<span class="kw">round</span>(<span class="kw">seconds_to_period</span>(tot_ts)))) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="dt">start=</span>recvDeployName.x, 
         <span class="dt">end=</span>recvDeployName.y, 
         <span class="dt">date=</span>ts.x, <span class="st">&quot;rate(m/s)&quot;</span> =<span class="st"> </span>rate, 
         dist, <span class="dt">total.time =</span> total.time, bearing)</code></pre></div>
<pre><code>## # A tibble: 2 x 7
##   start   end    date                `rate(m/s)`   dist total.time bearing
##   &lt;chr&gt;   &lt;chr&gt;  &lt;dttm&gt;                    &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;   &lt;dbl&gt;
## 1 Piskwa… Washk… 2016-10-09 22:49:59        20.3 7.63e⁴       3767     137
## 2 Washka… SHNJ_… 2016-10-10 00:00:42        24.3 1.27e⁶      52386     157</code></pre>
<p>Le Bécasseau maubèche a effectué un vol de 14,5 heures entre Washkaugou et SHNJ à la vitesse de 24 m/s, ce qui est plausible. Les chercheurs engagés dans le projet peuvent avoir d’autres données pour soutenir ou réfuter l’hypothèse (par exemple, l’observation de l’individu encore présent à Niapiskau après que le vol a été enregistré), mais il semble probable que, tandis qu’un émetteur est demeuré à différents points aux environs de la longitude -65, un autre émetteur porté par un individu qui a effectué les vols migratoires susmentionnés a été détecté. Nous pouvons produire un autre graphique plus détaillé de la puissance du signal pour examiner de plus près ces vols migratoires potentiels:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df.<span class="fl">56.</span>tmp &lt;-<span class="st"> </span><span class="kw">filter</span>(df.alltags.sub, ambigID <span class="op">==</span><span class="st"> </span><span class="op">-</span><span class="dv">56</span>, 
    recvLon <span class="op">&lt;</span><span class="st"> </span><span class="op">-</span><span class="dv">70</span>)

p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> df.<span class="fl">56.</span>tmp, <span class="kw">aes</span>(ts, sig, <span class="dt">colour =</span> <span class="kw">paste</span>(recvLat, 
    recvLon, recvDeployName, <span class="dt">sep =</span> <span class="st">&quot;: &quot;</span>)))
p <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">theme_bw</span>() <span class="op">+</span><span class="st"> </span><span class="kw">scale_colour_discrete</span>(<span class="dt">name =</span> <span class="st">&quot;Lat/Lon and</span><span class="ch">\n</span><span class="st">Station Name&quot;</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="kw">as_date</span>(ts), <span class="dt">scales =</span> <span class="st">&quot;free_x&quot;</span>)</code></pre></div>
<p><img src="FrMotusRBook_files/figure-html/ambig56e-1.png" width="672" /></p>
<p>Le graphique présente les profils typiques de passages en vol correspondant à la hausse puis à la baisse de la puissance du signal. Cela, ajouté aux profils de détection généraux et aux connaissances sur l’espèce, nous mène à croire que les détections ambiguës peuvent être raisonnablement divisées entre deux individus, l’un détecté en continu aux environs de la longitude -65 (émetteur 23316) et l’autre en migration vers le sud-ouest pendant la même période (émetteur 22867).</p>
<p>Pour résoudre le problème, nous devons créer deux filtres, l’un qui exclut les détections ambiguës de l’émetteur 22867 et l’autre qui exclut certaines détections de l’émetteur 23316. Dans le cas présent, l’approche la plus facile consiste à filtrer en fonction du motusTagID et du recvDeployName.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># L’émetteur 23316 était seulement à «Grande Île»</span>
<span class="co"># et à «Niapiskau» et l’émetteur 22867 n’a jamais</span>
<span class="co"># été détecté à ces deux endroits. Nous excluons</span>
<span class="co"># donc toutes les détections non effectuées à</span>
<span class="co"># «Grande Île» et à «Niapiskau» pour motusTag 23316</span>
<span class="co"># et nous faisons l’inverse pour l’émetteur 22867.</span>

df.block.<span class="dv">7</span> &lt;-<span class="st"> </span><span class="kw">filter</span>(df.alltags.sub, ambigID <span class="op">==</span><span class="st"> </span><span class="op">-</span><span class="dv">56</span>, 
    motusTagID <span class="op">==</span><span class="st"> </span><span class="dv">23316</span>, <span class="op">!</span>(recvDeployName <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Grand-Ile&quot;</span>, 
        <span class="st">&quot;Niapiskau&quot;</span>))) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(motusTagID, runID) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">distinct</span>()

df.block.<span class="dv">8</span> &lt;-<span class="st"> </span><span class="kw">filter</span>(df.alltags.sub, ambigID <span class="op">==</span><span class="st"> </span><span class="op">-</span><span class="dv">56</span>, 
    motusTagID <span class="op">==</span><span class="st"> </span><span class="dv">22867</span>, recvDeployName <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Grand-Ile&quot;</span>, 
        <span class="st">&quot;Niapiskau&quot;</span>)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(motusTagID, runID) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">distinct</span>()</code></pre></div>
</div>
<div id="verification-de-la-validite-des-sequences-dau-moins-2-detections" class="section level2">
<h2><span class="header-section-number">5.5</span> Vérification de la validité des séquences d’au moins 2 détections</h2>
<p>Au début du présent chapitre, nous avons supprimé toutes les détections faisant partie d’une séquence d’au moins 2, car on considère comme très probable qu’elles correspondent à de faux positifs. Maintenant que nous avons nettoyé les données et que nous avons un bon niveau de confiance quant aux détections qu’il reste, vous pourriez décider de revenir en arrière et d’examiner de plus près ces détections faisant partie d’une séquence d’au moins 2. Vous pourriez le faire, par exemple, en réexécutant les différents graphiques décrits dans ce chapitre (en commençant par les graphiques des coordonnées géographiques [latitude et longitude] en fonction du temps) pour voir si certaines de ces détections peuvent être considérées comme acceptables dans le contexte des positions correspondant aux détections acceptées. Il revient à l’utilisateur de déterminer quelles détections sont raisonnables en fonction de la biologie et du comportement de chaque animal portant un émetteur.</p>
</div>
<div id="filtrage-des-donnees" class="section level2">
<h2><span class="header-section-number">5.6</span> Filtrage des données</h2>
<div id="filtrer-et-enregistrer-le-resultat-dans-le-format-rds" class="section level3">
<h3><span class="header-section-number">5.6.1</span> Filtrer et enregistrer le résultat dans le format RDS</h3>
<p>Pour filtrer les données, nous pouvons simplement joindre de nouveau les trames de données df.block aux données originales en utilisant une fonction left_join() puis les éliminer des données:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Combinez les trames de données df.block en une</span>
<span class="co"># seule et ajoutez une probabilité de 0 pour les</span>
<span class="co"># enregistrements filtrés.</span>
df.block.all &lt;-<span class="st"> </span><span class="kw">bind_rows</span>(df.block.<span class="dv">0</span>, df.block.<span class="dv">1</span>, df.block.<span class="dv">2</span>, 
    df.block.<span class="dv">3</span>, df.block.<span class="dv">4</span>, df.block.<span class="dv">5</span>, df.block.<span class="dv">6</span>, 
    df.block.<span class="dv">7</span>, df.block.<span class="dv">8</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(<span class="dt">probability =</span> <span class="dv">0</span>)


df.alltags.sub &lt;-<span class="st"> </span><span class="kw">left_join</span>(df.alltags, df.block.all, 
    <span class="dt">by =</span> <span class="kw">c</span>(<span class="st">&quot;runID&quot;</span>, <span class="st">&quot;motusTagID&quot;</span>)) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># Attribuez une probabilité de 1 aux</span>
<span class="co"># enregistrements qui ne seront pas filtrés.</span>
<span class="kw">mutate</span>(<span class="dt">probability =</span> <span class="kw">ifelse</span>(<span class="kw">is.na</span>(probability), <span class="dv">1</span>, 
    probability)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(probability <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>)</code></pre></div>
<p>Maintenant, enregistrons la trame de données locale sous la forme d’un fichier RDS, que nous utiliserons dans le prochain chapitre. Comme il a été mentionné dans la section <a href="accessingData.html#exportDetections">3.8</a>, le format RDS conserve la structure des données R, y compris les estampilles temporelles. Le format RDS présente également l’avantage que les sorties d’un flux de travail déterminé sont enregistrées sous la forme d’un fichier plat, auquel on peut accéder de nouveau au moyen d’une simple instruction readRDS.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">saveRDS</span>(df.alltags.sub, <span class="dt">file =</span> <span class="st">&quot;./data/dfAlltagsSub.rds&quot;</span>)</code></pre></div>
<p>Et pour lire les données de nouveau:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df.alltags.sub &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;./data/dfAlltagsSub.rds&quot;</span>)</code></pre></div>
</div>
<div id="enregistrer-un-filtre-personnalise-dans-la-base-de-donnees-motus-et-lappliquer-aux-donnees" class="section level3">
<h3><span class="header-section-number">5.6.2</span> Enregistrer un filtre personnalisé dans la base de données motus et l’appliquer aux données</h3>
<p>Comme options de rechange à l’enregistrement des données sous la forme d’un fichier dans le format RDS, le logiciel R Motus intègre des fonctionnalités vous permettant d’enregistrer vos filtres directement dans votre fichier .motus. Une fois que vous aurez enregistré les filtres dans votre base de données, vous pouvez utiliser la fonction left_join() tel qu’indiqué précédemment sans avoir à recourir à des trames de données ou à un fichier RDS pour stocker vos données. Pour obtenir de plus amples renseignements sur les fonctions permettant de travailler avec des filtres Motus, reportez-vous à l’annexe D.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Combinez les trames de données df.block en une</span>
<span class="co"># seule et ajoutez une probabilité de 0 pour les</span>
<span class="co"># enregistrements filtrés.</span>
df.block.all &lt;-<span class="st"> </span><span class="kw">bind_rows</span>(df.block.<span class="dv">0</span>, df.block.<span class="dv">1</span>, df.block.<span class="dv">2</span>, 
    df.block.<span class="dv">3</span>, df.block.<span class="dv">4</span>, df.block.<span class="dv">5</span>, df.block.<span class="dv">6</span>, 
    df.block.<span class="dv">7</span>, df.block.<span class="dv">8</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(<span class="dt">probability =</span> <span class="dv">0</span>)

<span class="co"># Créez un nouveau filtre appelé filtAmbigFalsePos</span>
<span class="co"># et intégrez-y les données de la trame</span>
<span class="co"># df.block.all.</span>
tbl.filter =<span class="st"> </span><span class="kw">writeRunsFilter</span>(sql.motus, <span class="st">&quot;filtAmbigFalsePos&quot;</span>, 
    <span class="dt">df =</span> df.block.all, <span class="dt">delete =</span> <span class="ot">TRUE</span>)

<span class="co"># Obtenez un objet table duquel les enregistrements</span>
<span class="co"># filtrés à partir de tbl.filter.1 ont été retirés.</span>
tbl.alltags.sub &lt;-<span class="st"> </span><span class="kw">left_join</span>(tbl.alltags, tbl.filter, 
    <span class="dt">by =</span> <span class="kw">c</span>(<span class="st">&quot;runID&quot;</span>, <span class="st">&quot;motusTagID&quot;</span>)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(<span class="dt">probability =</span> <span class="kw">ifelse</span>(<span class="kw">is.na</span>(probability), 
    <span class="dv">1</span>, probability)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(probability <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>)</code></pre></div>

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="deployments.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="exploreData.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": ["FrMotusRBook.pdf", "FrMotusRBook.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

</body>

</html>
